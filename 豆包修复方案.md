通过仔细分析你的代码和豆包语音demo，我发现了几个关键问题导致无法正常收到服务器返回的消息。以下是主要问题和解决方案：

## 主要问题分析

### 1. 协议头生成错误
在 `doubaoVoiceClient.ts` 中，`generateHeader` 方法的 `headerSize` 计算不正确：
```
// src/utils/doubaoVoiceClient.ts - 修复版本

import { DoubaoVoiceConfig, RealtimeTranscriptEvent } from '@/types';

// 豆包协议常量
const PROTOCOL_VERSION = 0b0001;
const CLIENT_FULL_REQUEST = 0b0001;
const CLIENT_AUDIO_ONLY_REQUEST = 0b0010;
const SERVER_FULL_RESPONSE = 0b1001;
const SERVER_ACK = 0b1011;
const SERVER_ERROR_RESPONSE = 0b1111;
const NEG_SEQUENCE = 0b0010;
const MSG_WITH_EVENT = 0b0100;
const NO_SERIALIZATION = 0b0000;
const JSON_SERIALIZATION = 0b0001;
const GZIP = 0b0001;

export class DoubaoVoiceClient {
  private ws: WebSocket | null = null;
  private config: DoubaoVoiceConfig;
  private sessionId: string;
  private logId: string = '';
  private isConnected: boolean = false;
  private onEvent: (event: RealtimeTranscriptEvent) => void;

  constructor(config: DoubaoVoiceConfig, sessionId: string, onEvent: (event: RealtimeTranscriptEvent) => void) {
    this.config = config;
    this.sessionId = sessionId;
    this.onEvent = onEvent;
  }

  /**
   * 修复：正确的协议头生成 - 与豆包demo保持一致
   */
  private generateHeader(
    version = PROTOCOL_VERSION,
    messageType = CLIENT_FULL_REQUEST,
    messageTypeSpecificFlags = MSG_WITH_EVENT,
    serialMethod = JSON_SERIALIZATION,
    compressionType = GZIP,
    reservedData = 0x00,
    extensionHeader = new Uint8Array()
  ): Uint8Array {
    // 修复：按照豆包demo的计算方式
    const headerSize = Math.floor(extensionHeader.length / 4) + 1;
    const header = new Uint8Array(headerSize * 4);
    
    header[0] = (version << 4) | headerSize;
    header[1] = (messageType << 4) | messageTypeSpecificFlags;
    header[2] = (serialMethod << 4) | compressionType;
    header[3] = reservedData;
    
    if (extensionHeader.length > 0) {
      header.set(extensionHeader, 4);
    }
    
    return header;
  }

  /**
   * 修复：简化的GZIP压缩 - 如果不支持则跳过压缩
   */
  private async compressData(data: Uint8Array): Promise<Uint8Array> {
    try {
      if ('CompressionStream' in window) {
        const compressionStream = new CompressionStream('gzip');
        const writer = compressionStream.writable.getWriter();
        const reader = compressionStream.readable.getReader();
        
        writer.write(data);
        writer.close();
        
        const chunks: Uint8Array[] = [];
        let done = false;
        
        while (!done) {
          const { value, done: streamDone } = await reader.read();
          done = streamDone;
          if (value) {
            chunks.push(value);
          }
        }
        
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          result.set(chunk, offset);
          offset += chunk.length;
        }
        
        return result;
      } else {
        // 如果不支持压缩，返回原始数据，但要调整协议头
        console.warn('浏览器不支持GZIP压缩，使用无压缩模式');
        return data;
      }
    } catch (error) {
      console.error('GZIP压缩失败，使用原始数据:', error);
      return data;
    }
  }

  /**
   * 修复：改进的解压缩方法
   */
  private async decompressData(data: Uint8Array): Promise<Uint8Array> {
    try {
      if ('DecompressionStream' in window) {
        const decompressionStream = new DecompressionStream('gzip');
        const writer = decompressionStream.writable.getWriter();
        const reader = decompressionStream.readable.getReader();
        
        writer.write(data);
        writer.close();
        
        const chunks: Uint8Array[] = [];
        let done = false;
        
        while (!done) {
          const { value, done: streamDone } = await reader.read();
          done = streamDone;
          if (value) {
            chunks.push(value);
          }
        }
        
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          result.set(chunk, offset);
          offset += chunk.length;
        }
        
        return result;
      } else {
        return data;
      }
    } catch (error) {
      console.error('GZIP解压失败:', error);
      return data;
    }
  }

  private stringToUint8Array(str: string): Uint8Array {
    return new TextEncoder().encode(str);
  }

  private numberToBytes(num: number): Uint8Array {
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setUint32(0, num, false); // false = 大端序
    return new Uint8Array(buffer);
  }

  /**
   * 修复：直接连接豆包服务，不通过代理
   */
  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        // 直接连接豆包服务
        const doubaoUrl = 'wss://openspeech.bytedance.com/api/v3/realtime/dialogue';
        
        console.log('正在直接连接豆包服务:', doubaoUrl);
        
        this.ws = new WebSocket(doubaoUrl, [], {
          headers: {
            'X-Api-App-ID': this.config.apiAppId,
            'X-Api-Access-Key': this.config.apiAccessKey,
            'X-Api-Resource-Id': this.config.apiResourceId,
            'X-Api-App-Key': 'PlgvMymc7f3tQnJ6', // 从demo获取
            'X-Api-Connect-Id': this.generateConnectId(),
          }
        } as any);
        
        this.ws.binaryType = 'arraybuffer';

        let isInitialized = false;

        this.ws.onopen = async () => {
          console.log('WebSocket连接已建立，开始协议初始化...');
          
          try {
            // 1. 发送StartConnection
            await this.sendStartConnection();
            
            // 等待响应
            setTimeout(async () => {
              try {
                // 2. 发送StartSession
                await this.sendStartSession();
                isInitialized = true;
                this.isConnected = true;
                resolve();
              } catch (error) {
                reject(error);
              }
            }, 500);
            
          } catch (error) {
            reject(error);
          }
        };

        this.ws.onmessage = async (event) => {
          try {
            console.log('收到豆包服务器消息, 类型:', typeof event.data, '大小:', event.data.byteLength || event.data.length);
            await this.handleMessage(event.data);
          } catch (error) {
            console.error('处理消息失败:', error);
          }
        };

        this.ws.onerror = (error) => {
          console.error('WebSocket错误:', error);
          reject(new Error('连接豆包服务失败'));
        };

        this.ws.onclose = (event) => {
          console.log('WebSocket连接已关闭, code:', event.code, 'reason:', event.reason);
          this.isConnected = false;
          this.onEvent({ type: 'end', timestamp: Date.now() });
        };

        setTimeout(() => {
          if (this.ws && this.ws.readyState === WebSocket.CONNECTING) {
            this.ws.close();
            reject(new Error('连接超时'));
          }
        }, 10000);

      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * 发送StartConnection请求
   */
  private async sendStartConnection(): Promise<void> {
    const header = this.generateHeader();
    const payload = this.stringToUint8Array('{}');
    const compressedPayload = await this.compressData(payload);
    
    const message = new Uint8Array(header.length + 4 + 4 + compressedPayload.length);
    let offset = 0;
    
    message.set(header, offset);
    offset += header.length;
    
    message.set(this.numberToBytes(1), offset); // StartConnection event
    offset += 4;
    
    message.set(this.numberToBytes(compressedPayload.length), offset);
    offset += 4;
    
    message.set(compressedPayload, offset);
    
    console.log('发送StartConnection请求, 消息大小:', message.length);
    this.ws!.send(message);
  }

  /**
   * 发送StartSession请求
   */
  private async sendStartSession(): Promise<void> {
    const startSessionReq = {
      tts: {
        audio_config: {
          channel: 1,
          format: 'pcm',
          sample_rate: 24000
        }
      },
      dialog: {
        bot_name: '豆包'
      }
    };

    const header = this.generateHeader();
    const sessionIdBytes = this.stringToUint8Array(this.sessionId);
    const payload = this.stringToUint8Array(JSON.stringify(startSessionReq));
    const compressedPayload = await this.compressData(payload);
    
    const message = new Uint8Array(
      header.length + 4 + 4 + sessionIdBytes.length + 4 + compressedPayload.length
    );
    
    let offset = 0;
    message.set(header, offset);
    offset += header.length;
    
    message.set(this.numberToBytes(100), offset); // StartSession event
    offset += 4;
    
    message.set(this.numberToBytes(sessionIdBytes.length), offset);
    offset += 4;
    
    message.set(sessionIdBytes, offset);
    offset += sessionIdBytes.length;
    
    message.set(this.numberToBytes(compressedPayload.length), offset);
    offset += 4;
    
    message.set(compressedPayload, offset);
    
    console.log('发送StartSession请求, 消息大小:', message.length);
    this.ws!.send(message);
  }

  private generateConnectId(): string {
    return Date.now().toString() + Math.random().toString(36).substr(2, 9);
  }

  /**
   * 发送音频数据 - 修复版本
   */
  async sendAudio(audioData: ArrayBuffer): Promise<void> {
    if (!this.ws || !this.isConnected) {
      console.warn('WebSocket未连接');
      return;
    }

    try {
      // 使用无序列化、GZIP压缩的音频消息
      const header = this.generateHeader(
        PROTOCOL_VERSION,
        CLIENT_AUDIO_ONLY_REQUEST,
        MSG_WITH_EVENT,
        NO_SERIALIZATION, // 音频数据不需要JSON序列化
        GZIP
      );
      
      const sessionIdBytes = this.stringToUint8Array(this.sessionId);
      const audioBytes = new Uint8Array(audioData);
      const compressedAudio = await this.compressData(audioBytes);
      
      const message = new Uint8Array(
        header.length + 4 + 4 + sessionIdBytes.length + 4 + compressedAudio.length
      );
      
      let offset = 0;
      message.set(header, offset);
      offset += header.length;
      
      message.set(this.numberToBytes(200), offset); // Task request
      offset += 4;
      
      message.set(this.numberToBytes(sessionIdBytes.length), offset);
      offset += 4;
      
      message.set(sessionIdBytes, offset);
      offset += sessionIdBytes.length;
      
      message.set(this.numberToBytes(compressedAudio.length), offset);
      offset += 4;
      
      message.set(compressedAudio, offset);
      
      this.ws.send(message);
      console.log('音频数据已发送, 原始大小:', audioBytes.length, '压缩后:', compressedAudio.length);
      
    } catch (error) {
      console.error('发送音频数据失败:', error);
      this.onEvent({
        type: 'error',
        error: '发送音频数据失败',
        timestamp: Date.now()
      });
    }
  }

  /**
   * 修复：改进的消息处理
   */
  private async handleMessage(data: ArrayBuffer): Promise<void> {
    try {
      const response = await this.parseResponse(new Uint8Array(data));
      console.log('解析响应:', {
        messageType: response.messageType,
        event: response.event,
        payloadSize: response.payloadMsg instanceof Uint8Array ? response.payloadMsg.length : typeof response.payloadMsg
      });
      
      if (response.messageType === 'SERVER_ACK' && response.payloadMsg instanceof Uint8Array) {
        // 音频数据
        console.log('收到音频数据:', response.payloadMsg.length, '字节');
        this.onEvent({
          type: 'audio',
          audio: response.payloadMsg.buffer as ArrayBuffer,
          timestamp: Date.now()
        });
      } else if (response.messageType === 'SERVER_FULL_RESPONSE') {
        console.log('收到完整响应, event:', response.event);
        
        if (response.event === 450) {
          console.log('收到清空缓存指令');
        }
        
        if (typeof response.payloadMsg === 'string') {
          this.onEvent({
            type: 'transcript',
            text: response.payloadMsg,
            isFinal: true,
            timestamp: Date.now()
          });
        }
      } else if (response.messageType === 'SERVER_ERROR') {
        console.error('服务器错误:', response.payloadMsg);
        this.onEvent({
          type: 'error',
          error: response.payloadMsg as string,
          timestamp: Date.now()
        });
      }
    } catch (error) {
      console.error('处理消息失败:', error);
      this.onEvent({
        type: 'error',
        error: '消息处理失败',
        timestamp: Date.now()
      });
    }
  }

  /**
   * 解析服务器响应 - 与豆包demo保持一致
   */
  private async parseResponse(data: Uint8Array): Promise<{
    messageType?: string;
    event?: number;
    payloadMsg?: unknown;
    sessionId?: string;
    code?: number;
    seq?: number;
  }> {
    if (data.length < 4) {
      throw new Error('数据长度不足');
    }

    const protocolVersion = data[0] >> 4;
    const headerSize = data[0] & 0x0f;
    const messageType = data[1] >> 4;
    const messageTypeSpecificFlags = data[1] & 0x0f;
    const serializationMethod = data[2] >> 4;
    const messageCompression = data[2] & 0x0f;
    const reserved = data[3];
    
    console.log('解析响应头:', {
      protocolVersion,
      headerSize,
      messageType,
      messageTypeSpecificFlags,
      serializationMethod,
      messageCompression
    });
    
    const headerExtensions = data.slice(4, headerSize * 4);
    const payload = data.slice(headerSize * 4);
    
    const result: {
      messageType?: string;
      event?: number;
      payloadMsg?: unknown;
      sessionId?: string;
      code?: number;
      seq?: number;
    } = {};
    
    let payloadMsg: unknown = null;
    let start = 0;
    
    if (messageType === SERVER_FULL_RESPONSE || messageType === SERVER_ACK) {
      result.messageType = messageType === SERVER_ACK ? 'SERVER_ACK' : 'SERVER_FULL_RESPONSE';
      
      if (messageTypeSpecificFlags & NEG_SEQUENCE) {
        const view = new DataView(payload.buffer, payload.byteOffset + start, 4);
        result.seq = view.getUint32(0, false);
        start += 4;
      }
      
      if (messageTypeSpecificFlags & MSG_WITH_EVENT) {
        const view = new DataView(payload.buffer, payload.byteOffset + start, 4);
        result.event = view.getUint32(0, false);
        start += 4;
      }
      
      const remainingPayload = payload.slice(start);
      if (remainingPayload.length >= 4) {
        const view = new DataView(remainingPayload.buffer, remainingPayload.byteOffset, 4);
        const sessionIdSize = view.getInt32(0, false);
        
        if (remainingPayload.length >= 4 + sessionIdSize + 4) {
          const sessionId = remainingPayload.slice(4, 4 + sessionIdSize);
          result.sessionId = new TextDecoder().decode(sessionId);
          
          const payloadSizeView = new DataView(remainingPayload.buffer, remainingPayload.byteOffset + 4 + sessionIdSize, 4);
          const payloadSize = payloadSizeView.getUint32(0, false);
          
          payloadMsg = remainingPayload.slice(4 + sessionIdSize + 4, 4 + sessionIdSize + 4 + payloadSize);
        }
      }
    } else if (messageType === SERVER_ERROR_RESPONSE) {
      result.messageType = 'SERVER_ERROR';
      const view = new DataView(payload.buffer, payload.byteOffset, 4);
      result.code = view.getUint32(0, false);
      
      const payloadSizeView = new DataView(payload.buffer, payload.byteOffset + 4, 4);
      const payloadSize = payloadSizeView.getUint32(0, false);
      
      payloadMsg = payload.slice(8, 8 + payloadSize);
    }
    
    // 处理压缩和序列化
    if (payloadMsg instanceof Uint8Array) {
      if (messageCompression === GZIP) {
        try {
          payloadMsg = await this.decompressData(payloadMsg);
        } catch (error) {
          console.warn('解压失败，使用原始数据:', error);
        }
      }
      
      if (serializationMethod === JSON_SERIALIZATION) {
        try {
          const text = new TextDecoder().decode(payloadMsg);
          payloadMsg = JSON.parse(text);
        } catch (error) {
          console.warn('JSON解析失败，使用原始文本:', error);
          payloadMsg = new TextDecoder().decode(payloadMsg);
        }
      } else if (serializationMethod !== NO_SERIALIZATION) {
        payloadMsg = new TextDecoder().decode(payloadMsg);
      }
    }
    
    result.payloadMsg = payloadMsg;
    return result;
  }

  async endSession(): Promise<void> {
    if (!this.ws || !this.isConnected) return;

    try {
      const header = this.generateHeader();
      const sessionIdBytes = this.stringToUint8Array(this.sessionId);
      const payload = this.stringToUint8Array('{}');
      const compressedPayload = await this.compressData(payload);
      
      const message = new Uint8Array(
        header.length + 4 + 4 + sessionIdBytes.length + 4 + compressedPayload.length
      );
      
      let offset = 0;
      message.set(header, offset);
      offset += header.length;
      
      message.set(this.numberToBytes(102), offset); // FinishSession
      offset += 4;
      
      message.set(this.numberToBytes(sessionIdBytes.length), offset);
      offset += 4;
      
      message.set(sessionIdBytes, offset);
      offset += sessionIdBytes.length;
      
      message.set(this.numberToBytes(compressedPayload.length), offset);
      offset += 4;
      
      message.set(compressedPayload, offset);
      
      this.ws.send(message);
      console.log('已发送结束会话请求');
    } catch (error) {
      console.error('结束会话失败:', error);
    }
  }

  async close(): Promise<void> {
    if (!this.ws) return;

    try {
      await this.endSession();
      await new Promise(resolve => setTimeout(resolve, 100));
      this.ws.close();
      this.isConnected = false;
    } catch (error) {
      console.error('关闭连接失败:', error);
      if (this.ws) {
        this.ws.close();
      }
    }
  }

  isConnectionActive(): boolean {
    return this.isConnected && this.ws?.readyState === WebSocket.OPEN;
  }
}
```


### 2. 服务器代理问题修复

你的 `server.js` 代理实现也有问题，以下是修复版本：
```
// server.js - 修复版本
const { createServer } = require('http');
const { parse } = require('url');
const next = require('next');
const WebSocket = require('ws');
const zlib = require('zlib');
const { promisify } = require('util');

const gzipAsync = promisify(zlib.gzip);
const gunzipAsync = promisify(zlib.gunzip);

const dev = process.env.NODE_ENV !== 'production';
const hostname = 'localhost';
const port = process.env.PORT || 3000;

const app = next({ dev, hostname, port });
const handle = app.getRequestHandler();

// 豆包协议常量
const PROTOCOL_VERSION = 0b0001;
const CLIENT_FULL_REQUEST = 0b0001;
const CLIENT_AUDIO_ONLY_REQUEST = 0b0010;
const SERVER_FULL_RESPONSE = 0b1001;
const SERVER_ACK = 0b1011;
const SERVER_ERROR_RESPONSE = 0b1111;
const NEG_SEQUENCE = 0b0010;
const MSG_WITH_EVENT = 0b0100;
const NO_SERIALIZATION = 0b0000;
const JSON_SERIALIZATION = 0b0001;
const GZIP = 0b0001;

// 生成协议头 - 修复版本
function generateHeader(
  version = PROTOCOL_VERSION,
  messageType = CLIENT_FULL_REQUEST,
  messageTypeSpecificFlags = MSG_WITH_EVENT,
  serialMethod = JSON_SERIALIZATION,
  compressionType = GZIP,
  reservedData = 0x00,
  extensionHeader = Buffer.alloc(0)
) {
  // 修复：正确计算headerSize
  const headerSize = Math.floor(extensionHeader.length / 4) + 1;
  const header = Buffer.alloc(headerSize * 4);
  
  header[0] = (version << 4) | headerSize;
  header[1] = (messageType << 4) | messageTypeSpecificFlags;
  header[2] = (serialMethod << 4) | compressionType;
  header[3] = reservedData;
  
  if (extensionHeader.length > 0) {
    extensionHeader.copy(header, 4);
  }
  
  return header;
}

// 数字转换为4字节大端序
function numberToBytes(num) {
  const buffer = Buffer.alloc(4);
  buffer.writeUInt32BE(num, 0);
  return buffer;
}

// 生成连接ID
function generateConnectId() {
  return Date.now().toString() + Math.random().toString(36).substr(2, 9);
}

app.prepare().then(() => {
  const server = createServer(async (req, res) => {
    try {
      const parsedUrl = parse(req.url, true);
      await handle(req, res, parsedUrl);
    } catch (err) {
      console.error('Error occurred handling', req.url, err);
      res.statusCode = 500;
      res.end('internal server error');
    }
  });

  // 创建WebSocket服务器
  const wss = new WebSocket.Server({ 
    server,
    path: '/api/voice/realtime'
  });

  wss.on('connection', (clientWs, req) => {
    console.log('新的客户端WebSocket连接');
    
    const url = parse(req.url, true);
    const sessionId = url.query.sessionId;
    
    if (!sessionId) {
      console.error('缺少会话ID');
      clientWs.close(1008, '缺少会话ID');
      return;
    }

    console.log('会话ID:', sessionId);

    let doubaoWs = null;
    let isConnected = false;
    let isProtocolInitialized = false;

    // 连接到豆包服务
    const connectToDoubao = async () => {
      try {
        console.log('正在连接到豆包服务...');
        
        // 完整的豆包WebSocket headers
        const headers = {
          'X-Api-App-ID': '2139817228',
          'X-Api-Access-Key': 'LMxFTYn2mmWwQwmLfT3ZbwS4yj0JPiMt',
          'X-Api-Resource-Id': 'volc.speech.dialog',
          'X-Api-App-Key': 'PlgvMymc7f3tQnJ6',
          'X-Api-Connect-Id': generateConnectId()
        };

        console.log('连接头信息:', headers);

        doubaoWs = new WebSocket('wss://openspeech.bytedance.com/api/v3/realtime/dialogue', {
          headers: headers
        });

        doubaoWs.on('open', async () => {
          console.log('豆包WebSocket连接已建立，开始协议初始化...');
          
          try {
            // 发送StartConnection请求
            await sendStartConnection();
            
            // 等待一下再发送StartSession
            setTimeout(async () => {
              try {
                await sendStartSession();
                isProtocolInitialized = true;
                isConnected = true;
                
                // 通知客户端连接成功
                clientWs.send(JSON.stringify({
                  type: 'connected',
                  sessionId: sessionId
                }));
                
                console.log('豆包协议初始化完成');
              } catch (error) {
                console.error('StartSession失败:', error);
                clientWs.send(JSON.stringify({
                  type: 'error',
                  error: 'StartSession失败: ' + error.message
                }));
              }
            }, 500);
            
          } catch (error) {
            console.error('StartConnection失败:', error);
            clientWs.send(JSON.stringify({
              type: 'error',
              error: 'StartConnection失败: ' + error.message
            }));
          }
        });

        // 发送StartConnection请求
        const sendStartConnection = async () => {
          try {
            const header = generateHeader();
            const payload = Buffer.from('{}');
            const compressedPayload = await gzipAsync(payload);
            
            const message = Buffer.concat([
              header,
              numberToBytes(1), // StartConnection event
              numberToBytes(compressedPayload.length),
              compressedPayload
            ]);
            
            doubaoWs.send(message);
            console.log('已发送StartConnection请求, 大小:', message.length);
          } catch (error) {
            console.error('发送StartConnection失败:', error);
            throw error;
          }
        };

        // 发送StartSession请求
        const sendStartSession = async () => {
          try {
            const startSessionReq = {
              tts: {
                audio_config: {
                  channel: 1,
                  format: 'pcm',
                  sample_rate: 24000
                }
              },
              dialog: {
                bot_name: '豆包'
              }
            };

            const header = generateHeader();
            const sessionIdBytes = Buffer.from(sessionId);
            const payload = Buffer.from(JSON.stringify(startSessionReq));
            const compressedPayload = await gzipAsync(payload);
            
            const message = Buffer.concat([
              header,
              numberToBytes(100), // StartSession event
              numberToBytes(sessionIdBytes.length),
              sessionIdBytes,
              numberToBytes(compressedPayload.length),
              compressedPayload
            ]);
            
            doubaoWs.send(message);
            console.log('已发送StartSession请求, 大小:', message.length);
          } catch (error) {
            console.error('发送StartSession失败:', error);
            throw error;
          }
        };

        doubaoWs.on('message', async (data) => {
          try {
            console.log('收到豆包消息, 大小:', data.length);
            
            // 解析豆包响应
            const response = await parseDoubaoResponse(data);
            console.log('解析结果:', {
              messageType: response.messageType,
              event: response.event,
              payloadType: typeof response.payloadMsg,
              payloadSize: response.payloadMsg instanceof Buffer ? response.payloadMsg.length : 'N/A'
            });
            
            // 直接转发原始二进制数据给客户端
            if (clientWs.readyState === WebSocket.OPEN) {
              clientWs.send(data);
            }
          } catch (error) {
            console.error('处理豆包消息失败:', error);
            clientWs.send(JSON.stringify({
              type: 'error',
              error: '处理豆包消息失败: ' + error.message
            }));
          }
        });

        doubaoWs.on('error', (error) => {
          console.error('豆包WebSocket错误:', error);
          clientWs.send(JSON.stringify({
            type: 'error',
            error: '豆包服务连接错误: ' + error.message
          }));
        });

        doubaoWs.on('close', (code, reason) => {
          console.log('豆包WebSocket连接已关闭, code:', code, 'reason:', reason.toString());
          isConnected = false;
          if (clientWs.readyState === WebSocket.OPEN) {
            clientWs.send(JSON.stringify({
              type: 'end'
            }));
          }
        });

      } catch (error) {
        console.error('连接豆包服务失败:', error);
        clientWs.send(JSON.stringify({
          type: 'error',
          error: '无法连接到豆包服务: ' + error.message
        }));
      }
    };

    // 处理客户端消息
    clientWs.on('message', (message) => {
      try {
        // 检查是否是二进制消息（音频数据）
        if (Buffer.isBuffer(message)) {
          console.log('收到客户端音频数据, 大小:', message.length);
          
          if (doubaoWs && isConnected && isProtocolInitialized && doubaoWs.readyState === WebSocket.OPEN) {
            // 直接转发音频数据到豆包
            doubaoWs.send(message);
          } else {
            console.warn('豆包连接未就绪，忽略音频数据');
          }
        } else {
          // JSON消息处理
          try {
            const jsonMessage = JSON.parse(message.toString());
            console.log('收到客户端JSON消息:', jsonMessage.type);
            
            // 根据消息类型处理
            switch (jsonMessage.type) {
              case 'ping':
                clientWs.send(JSON.stringify({ type: 'pong' }));
                break;
              default:
                console.log('未处理的消息类型:', jsonMessage.type);
            }
          } catch (error) {
            console.error('解析客户端JSON消息失败:', error);
          }
        }
      } catch (error) {
        console.error('处理客户端消息失败:', error);
      }
    });

    clientWs.on('close', () => {
      console.log('客户端WebSocket连接已关闭');
      
      // 清理豆包连接
      if (doubaoWs && doubaoWs.readyState === WebSocket.OPEN) {
        try {
          sendFinishSession().then(() => {
            setTimeout(() => {
              sendFinishConnection().then(() => {
                setTimeout(() => {
                  doubaoWs.close();
                }, 100);
              });
            }, 100);
          });
        } catch (error) {
          console.error('发送结束请求失败:', error);
          doubaoWs.close();
        }
      }
    });

    clientWs.on('error', (error) => {
      console.error('客户端WebSocket错误:', error);
      if (doubaoWs && doubaoWs.readyState === WebSocket.OPEN) {
        doubaoWs.close();
      }
    });

    // 发送结束会话请求
    const sendFinishSession = async () => {
      if (!doubaoWs || doubaoWs.readyState !== WebSocket.OPEN) return;
      
      try {
        const header = generateHeader();
        const sessionIdBytes = Buffer.from(sessionId);
        const payload = Buffer.from('{}');
        const compressedPayload = await gzipAsync(payload);
        
        const message = Buffer.concat([
          header,
          numberToBytes(102), // FinishSession event
          numberToBytes(sessionIdBytes.length),
          sessionIdBytes,
          numberToBytes(compressedPayload.length),
          compressedPayload
        ]);
        
        doubaoWs.send(message);
        console.log('已发送FinishSession请求');
      } catch (error) {
        console.error('发送FinishSession失败:', error);
      }
    };

    // 发送结束连接请求
    const sendFinishConnection = async () => {
      if (!doubaoWs || doubaoWs.readyState !== WebSocket.OPEN) return;
      
      try {
        const header = generateHeader();
        const payload = Buffer.from('{}');
        const compressedPayload = await gzipAsync(payload);
        
        const message = Buffer.concat([
          header,
          numberToBytes(2), // FinishConnection event
          numberToBytes(compressedPayload.length),
          compressedPayload
        ]);
        
        doubaoWs.send(message);
        console.log('已发送FinishConnection请求');
      } catch (error) {
        console.error('发送FinishConnection失败:', error);
      }
    };

    // 开始连接到豆包
    connectToDoubao();
  });

  // 解析豆包响应的函数
  async function parseDoubaoResponse(data) {
    if (data.length < 4) {
      throw new Error('数据长度不足');
    }

    const protocolVersion = data[0] >> 4;
    const headerSize = data[0] & 0x0f;
    const messageType = data[1] >> 4;
    const messageTypeSpecificFlags = data[1] & 0x0f;
    const serializationMethod = data[2] >> 4;
    const messageCompression = data[2] & 0x0f;
    const reserved = data[3];
    
    const headerExtensions = data.slice(4, headerSize * 4);
    const payload = data.slice(headerSize * 4);
    
    const result = {};
    let payloadMsg = null;
    let start = 0;
    
    if (messageType === SERVER_FULL_RESPONSE || messageType === SERVER_ACK) {
      result.messageType = messageType === SERVER_ACK ? 'SERVER_ACK' : 'SERVER_FULL_RESPONSE';
      
      if (messageTypeSpecificFlags & NEG_SEQUENCE) {
        result.seq = payload.readUInt32BE(start);
        start += 4;
      }
      
      if (messageTypeSpecificFlags & MSG_WITH_EVENT) {
        result.event = payload.readUInt32BE(start);
        start += 4;
      }
      
      const remainingPayload = payload.slice(start);
      if (remainingPayload.length >= 4) {
        const sessionIdSize = remainingPayload.readInt32BE(0);
        
        if (remainingPayload.length >= 4 + sessionIdSize + 4) {
          const sessionId = remainingPayload.slice(4, 4 + sessionIdSize);
          result.sessionId = sessionId.toString();
          
          const payloadSize = remainingPayload.readUInt32BE(4 + sessionIdSize);
          payloadMsg = remainingPayload.slice(4 + sessionIdSize + 4, 4 + sessionIdSize + 4 + payloadSize);
        }
      }
    } else if (messageType === SERVER_ERROR_RESPONSE) {
      result.messageType = 'SERVER_ERROR';
      result.code = payload.readUInt32BE(0);
      
      const payloadSize = payload.readUInt32BE(4);
      payloadMsg = payload.slice(8, 8 + payloadSize);
    }
    
    // 处理压缩和序列化
    if (payloadMsg && payloadMsg.length > 0) {
      if (messageCompression === GZIP) {
        try {
          payloadMsg = await gunzipAsync(payloadMsg);
        } catch (error) {
          console.warn('解压失败，使用原始数据:', error);
        }
      }
      
      if (serializationMethod === JSON_SERIALIZATION) {
        try {
          const text = payloadMsg.toString('utf8');
          payloadMsg = JSON.parse(text);
        } catch (error) {
          console.warn('JSON解析失败，使用原始文本:', error);
          payloadMsg = payloadMsg.toString('utf8');
        }
      } else if (serializationMethod !== NO_SERIALIZATION) {
        payloadMsg = payloadMsg.toString('utf8');
      }
    }
    
    result.payloadMsg = payloadMsg;
    return result;
  }

  server.listen(port, (err) => {
    if (err) throw err;
    console.log(`> Ready on http://${hostname}:${port}`);
    console.log('> WebSocket代理服务器已启动在 /api/voice/realtime');
  });
});
```
### 3. VoiceCallManager 修复

你还需要修改 `VoiceCallManager` 来使用代理服务器：
```
// src/utils/voiceCallManager.ts - 修复版本

import { DoubaoVoiceClient } from './doubaoVoiceClient';
import { AudioProcessor } from './audioProcessor';
import { 
  DoubaoVoiceConfig, 
  VoiceCallState, 
  RealtimeTranscriptEvent,
  AudioVisualizationData 
} from '@/types';

export class VoiceCallManager {
  private doubaoClient: DoubaoVoiceClient | null = null;
  private audioProcessor: AudioProcessor | null = null;
  private config: DoubaoVoiceConfig;
  private sessionId: string;
  private callState: VoiceCallState;
  private silenceTimer: NodeJS.Timeout | null = null;
  private callStartTime: number = 0;
  private onStateChange: (state: VoiceCallState) => void;
  private onTranscriptUpdate: (transcript: string) => void;
  private onVisualizationData: (data: AudioVisualizationData) => void;

  constructor(
    config: DoubaoVoiceConfig,
    sessionId: string,
    onStateChange: (state: VoiceCallState) => void,
    onTranscriptUpdate: (transcript: string) => void,
    onVisualizationData: (data: AudioVisualizationData) => void
  ) {
    this.config = config;
    this.sessionId = sessionId;
    this.onStateChange = onStateChange;
    this.onTranscriptUpdate = onTranscriptUpdate;
    this.onVisualizationData = onVisualizationData;

    this.callState = {
      mode: 'voice-call',
      isCallActive: false,
      connectionStatus: 'idle',
      callDuration: 0,
      silenceTimer: 0,
      realtimeTranscript: '',
      audioQuality: 'medium',
      sessionId,
      lastActivity: Date.now()
    };

    this.audioProcessor = new AudioProcessor();
  }

  /**
   * 修复：使用代理服务器的连接方式
   */
  async startCall(): Promise<void> {
    try {
      console.log('开始语音通话流程...');
      
      this.updateCallState({
        connectionStatus: 'connecting',
        isCallActive: false
      });

      // 检查浏览器支持
      const support = AudioProcessor.checkSupport();
      if (!support.mediaDevices || !support.audioContext) {
        throw new Error('浏览器不支持语音通话功能，请使用Chrome、Firefox或Edge浏览器');
      }

      console.log('浏览器支持检查通过');

      // 修复：使用WebSocket代理URL而不是直接连接豆包
      // 从API获取的WebSocket URL应该是代理服务器地址
      if (!this.config.baseUrl.includes('/api/voice/realtime')) {
        throw new Error('WebSocket URL配置错误，应该指向代理服务器');
      }

      console.log('使用WebSocket代理URL:', this.config.baseUrl);

      // 初始化豆包语音客户端
      console.log('正在初始化豆包语音客户端...');
      this.doubaoClient = new DoubaoVoiceClient(
        this.config,
        this.sessionId,
        this.handleDoubaoEvent.bind(this)
      );

      // 连接代理服务
      console.log('正在连接代理服务...');
      await this.doubaoClient.connect();
      console.log('代理服务连接成功');

      // 开始音频捕获
      console.log('正在启动音频捕获...');
      await this.audioProcessor!.startCapture(
        this.handleAudioData.bind(this),
        this.handleSilenceDetected.bind(this),
        this.onVisualizationData
      );
      console.log('音频捕获启动成功');

      this.callStartTime = Date.now();
      this.updateCallState({
        connectionStatus: 'connected',
        isCallActive: true,
        lastActivity: Date.now()
      });

      this.startCallTimer();
      this.resetSilenceTimer();
      
      console.log('语音通话已开始');

    } catch (error) {
      console.error('开始语音通话失败:', error);
      
      // 清理资源
      await this.cleanup();
      
      this.updateCallState({
        connectionStatus: 'error',
        isCallActive: false
      });
      
      throw error;
    }
  }

  /**
   * 修复：改进的事件处理
   */
  private handleDoubaoEvent(event: RealtimeTranscriptEvent): void {
    console.log('收到豆包事件:', event.type);
    
    switch (event.type) {
      case 'transcript':
        if (event.text) {
          console.log('收到转录文本:', event.text);
          this.updateCallState({
            realtimeTranscript: event.text,
            lastActivity: Date.now()
          });
          this.onTranscriptUpdate(event.text);
          this.resetSilenceTimer();
        }
        break;

      case 'audio':
        if (event.audio) {
          console.log('收到音频数据:', event.audio.byteLength, '字节');
          this.playAudioData(event.audio);
          this.updateCallState({ lastActivity: Date.now() });
          this.resetSilenceTimer();
        }
        break;

      case 'error':
        console.error('豆包语音错误:', event.error);
        this.endCall('error');
        break;

      case 'end':
        console.log('豆包会话结束');
        this.endCall('timeout');
        break;
    }
  }

  /**
   * 修复：改进的音频数据处理
   */
  private handleAudioData(audioData: ArrayBuffer): void {
    if (!this.doubaoClient || !this.doubaoClient.isConnectionActive()) {
      console.warn('豆包客户端未连接，跳过音频数据发送');
      return;
    }

    try {
      console.log('发送音频数据到豆包，大小:', audioData.byteLength);
      this.doubaoClient.sendAudio(audioData);
      this.updateCallState({ lastActivity: Date.now() });
      this.resetSilenceTimer();
    } catch (error) {
      console.error('处理音频数据失败:', error);
      // 不要因为单次音频数据发送失败就结束通话
    }
  }

  private handleSilenceDetected(duration: number): void {
    console.log('检测到静音:', duration, 'ms');
    if (this.config.silenceDetection && duration >= this.config.callTimeout) {
      console.log(`静音超过${this.config.callTimeout}ms，准备结束通话`);
      this.endCall('silence_timeout');
    }
  }

  /**
   * 修复：改进的音频播放
   */
  private async playAudioData(audioData: ArrayBuffer): Promise<void> {
    try {
      console.log('准备播放音频，大小:', audioData.byteLength);
      
      // 检查数据是否为有效的音频格式
      if (audioData.byteLength === 0) {
        console.warn('音频数据为空，跳过播放');
        return;
      }

      // 创建音频上下文
      const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
      if (!AudioContextClass) {
        throw new Error('浏览器不支持AudioContext');
      }
      
      const audioContext = new AudioContextClass();
      
      // 确保音频上下文处于运行状态
      if (audioContext.state === 'suspended') {
        await audioContext.resume();
      }
      
      try {
        // 尝试解码音频数据
        const audioBuffer = await audioContext.decodeAudioData(audioData.slice(0));
        
        // 创建音频源并播放
        const source = audioContext.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(audioContext.destination);
        source.start();
        
        console.log('音频播放成功，时长:', audioBuffer.duration, '秒');
        
        // 播放完成后清理
        source.onended = () => {
          audioContext.close();
        };
        
      } catch (decodeError) {
        console.error('音频解码失败:', decodeError);
        // 如果是PCM数据，尝试作为原始PCM处理
        await this.playRawPCMData(audioData, audioContext);
      }
      
    } catch (error) {
      console.error('播放音频失败:', error);
    }
  }

  /**
   * 新增：播放原始PCM数据
   */
  private async playRawPCMData(audioData: ArrayBuffer, audioContext: AudioContext): Promise<void> {
    try {
      console.log('尝试作为PCM数据播放');
      
      // 假设是16位单声道PCM，采样率24000Hz（豆包输出格式）
      const sampleRate = 24000;
      const channels = 1;
      const bytesPerSample = 2; // 16位 = 2字节
      
      const int16Array = new Int16Array(audioData);
      const float32Array = new Float32Array(int16Array.length);
      
      // 转换为Float32格式
      for (let i = 0; i < int16Array.length; i++) {
        float32Array[i] = int16Array[i] / 32768.0; // 归一化到-1到1
      }
      
      // 创建音频缓冲区
      const audioBuffer = audioContext.createBuffer(
        channels, 
        float32Array.length, 
        sampleRate
      );
      
      audioBuffer.copyToChannel(float32Array, 0);
      
      // 创建音频源并播放
      const source = audioContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(audioContext.destination);
      source.start();
      
      console.log('PCM音频播放成功，采样数:', float32Array.length);
      
    } catch (error) {
      console.error('PCM音频播放失败:', error);
    }
  }

  async endCall(reason: 'user_hangup' | 'timeout' | 'error' | 'silence_timeout' = 'user_hangup'): Promise<void> {
    try {
      console.log('结束语音通话，原因:', reason);
      
      this.stopSilenceTimer();
      await this.cleanup();
      
      this.updateCallState({
        connectionStatus: 'disconnected',
        isCallActive: false
      });

      // 调用结束通话API
      try {
        const response = await fetch('/api/voice/end', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            sessionId: this.sessionId,
            reason,
            duration: Date.now() - this.callStartTime
          }),
        });

        if (!response.ok) {
          console.warn('结束通话API调用失败');
        }
      } catch (error) {
        console.warn('结束通话API调用错误:', error);
      }

      console.log('语音通话已结束');

    } catch (error) {
      console.error('结束语音通话失败:', error);
    }
  }

  /**
   * 新增：资源清理方法
   */
  private async cleanup(): Promise<void> {
    try {
      // 停止音频捕获
      if (this.audioProcessor) {
        this.audioProcessor.stopCapture();
      }

      // 关闭豆包连接
      if (this.doubaoClient) {
        await this.doubaoClient.close();
        this.doubaoClient = null;
      }
    } catch (error) {
      console.error('清理资源失败:', error);
    }
  }

  private resetSilenceTimer(): void {
    this.stopSilenceTimer();
    
    if (this.config.silenceDetection && this.callState.isCallActive) {
      this.silenceTimer = setTimeout(() => {
        console.log('静音超时，结束通话');
        this.endCall('silence_timeout');
      }, this.config.callTimeout);
    }
  }

  private stopSilenceTimer(): void {
    if (this.silenceTimer) {
      clearTimeout(this.silenceTimer);
      this.silenceTimer = null;
    }
  }

  private startCallTimer(): void {
    const updateDuration = () => {
      if (this.callState.isCallActive) {
        const duration = Date.now() - this.callStartTime;
        this.updateCallState({ callDuration: duration });
        setTimeout(updateDuration, 1000);
      }
    };
    updateDuration();
  }

  private updateCallState(updates: Partial<VoiceCallState>): void {
    this.callState = { ...this.callState, ...updates };
    this.onStateChange(this.callState);
  }

  toggleMute(): void {
    console.log('切换静音状态');
    // TODO: 实现静音功能
  }

  togglePause(): void {
    console.log('切换暂停状态');
    // TODO: 实现暂停功能
  }

  getCallState(): VoiceCallState {
    return { ...this.callState };
  }

  isCallActive(): boolean {
    return this.callState.isCallActive && this.callState.connectionStatus === 'connected';
  }

  dispose(): void {
    this.endCall('user_hangup');
    
    if (this.audioProcessor) {
      this.audioProcessor.dispose();
      this.audioProcessor = null;
    }

    this.stopSilenceTimer();
  }
}
```
### 4. 代理连接版本的 DoubaoVoiceClient

由于浏览器的CORS限制，你需要使用代理服务器。以下是专门用于连接代理的版本：
```
// src/utils/doubaoVoiceClient.ts - 代理连接版本

import { DoubaoVoiceConfig, RealtimeTranscriptEvent } from '@/types';

// 豆包协议常量
const PROTOCOL_VERSION = 0b0001;
const CLIENT_AUDIO_ONLY_REQUEST = 0b0010;
const SERVER_FULL_RESPONSE = 0b1001;
const SERVER_ACK = 0b1011;
const SERVER_ERROR_RESPONSE = 0b1111;
const NEG_SEQUENCE = 0b0010;
const MSG_WITH_EVENT = 0b0100;
const NO_SERIALIZATION = 0b0000;
const JSON_SERIALIZATION = 0b0001;
const GZIP = 0b0001;

/**
 * 豆包实时语音客户端 - 代理连接版本
 * 通过WebSocket代理服务器与豆包服务通信
 */
export class DoubaoVoiceClient {
  private ws: WebSocket | null = null;
  private config: DoubaoVoiceConfig;
  private sessionId: string;
  private isConnected: boolean = false;
  private onEvent: (event: RealtimeTranscriptEvent) => void;

  constructor(config: DoubaoVoiceConfig, sessionId: string, onEvent: (event: RealtimeTranscriptEvent) => void) {
    this.config = config;
    this.sessionId = sessionId;
    this.onEvent = onEvent;
  }

  /**
   * 连接到代理服务器
   */
  async connect(): Promise<void> {
    return new Promise((resolve, reject) => {
      try {
        console.log('正在连接WebSocket代理服务器:', this.config.baseUrl);
        
        this.ws = new WebSocket(this.config.baseUrl);
        this.ws.binaryType = 'arraybuffer';

        let isInitialized = false;

        this.ws.onopen = () => {
          console.log('WebSocket代理连接已建立，等待豆包服务初始化...');
        };

        this.ws.onmessage = async (event) => {
          try {
            if (typeof event.data === 'string') {
              // JSON消息处理
              const message = JSON.parse(event.data);
              console.log('收到代理服务器消息:', message.type);
              
              switch (message.type) {
                case 'connected':
                  if (!isInitialized) {
                    console.log('豆包服务连接成功，协议初始化完成');
                    isInitialized = true;
                    this.isConnected = true;
                    resolve();
                  }
                  break;
                  
                case 'error':
                  console.error('代理服务器错误:', message.error);
                  reject(new Error(message.error));
                  break;
                  
                case 'end':
                  console.log('豆包服务连接已结束');
                  this.isConnected = false;
                  this.onEvent({ type: 'end', timestamp: Date.now() });
                  break;
              }
            } else {
              // 二进制消息处理（豆包响应数据）
              console.log('收到豆包二进制响应，大小:', event.data.byteLength);
              await this.handleMessage(event.data);
            }
          } catch (error) {
            console.error('处理WebSocket消息失败:', error);
            if (!isInitialized) {
              reject(error);
            }
          }
        };

        this.ws.onerror = (error) => {
          console.error('WebSocket连接错误:', error);
          reject(new Error('WebSocket连接失败'));
        };

        this.ws.onclose = (event) => {
          console.log('WebSocket连接已关闭, code:', event.code, 'reason:', event.reason);
          this.isConnected = false;
          this.onEvent({ type: 'end', timestamp: Date.now() });
        };

        // 连接超时
        setTimeout(() => {
          if (!isInitialized && this.ws && this.ws.readyState === WebSocket.CONNECTING) {
            this.ws.close();
            reject(new Error('WebSocket连接超时'));
          }
        }, 15000); // 15秒超时

      } catch (error) {
        reject(error);
      }
    });
  }

  /**
   * 发送音频数据到代理服务器
   */
  async sendAudio(audioData: ArrayBuffer): Promise<void> {
    if (!this.ws || !this.isConnected) {
      console.warn('WebSocket未连接，无法发送音频数据');
      return;
    }

    try {
      console.log('准备发送音频数据到代理服务器，大小:', audioData.byteLength);
      
      // 生成豆包协议格式的音频消息
      const header = this.generateHeader(
        PROTOCOL_VERSION,
        CLIENT_AUDIO_ONLY_REQUEST,
        MSG_WITH_EVENT,
        NO_SERIALIZATION,
        GZIP
      );
      
      const sessionIdBytes = this.stringToUint8Array(this.sessionId);
      const audioBytes = new Uint8Array(audioData);
      const compressedAudio = await this.compressData(audioBytes);
      
      const message = new Uint8Array(
        header.length + 4 + 4 + sessionIdBytes.length + 4 + compressedAudio.length
      );
      
      let offset = 0;
      message.set(header, offset);
      offset += header.length;
      
      message.set(this.numberToBytes(200), offset); // Task request
      offset += 4;
      
      message.set(this.numberToBytes(sessionIdBytes.length), offset);
      offset += 4;
      
      message.set(sessionIdBytes, offset);
      offset += sessionIdBytes.length;
      
      message.set(this.numberToBytes(compressedAudio.length), offset);
      offset += 4;
      
      message.set(compressedAudio, offset);
      
      if (this.ws.readyState === WebSocket.OPEN) {
        this.ws.send(message);
        console.log('音频数据已发送到代理服务器，总消息大小:', message.length);
      } else {
        console.warn('WebSocket连接状态异常:', this.ws.readyState);
      }
    } catch (error) {
      console.error('发送音频数据失败:', error);
      this.onEvent({
        type: 'error',
        error: '发送音频数据失败: ' + (error instanceof Error ? error.message : '未知错误'),
        timestamp: Date.now()
      });
    }
  }

  /**
   * 生成协议头部
   */
  private generateHeader(
    version = PROTOCOL_VERSION,
    messageType = CLIENT_AUDIO_ONLY_REQUEST,
    messageTypeSpecificFlags = MSG_WITH_EVENT,
    serialMethod = NO_SERIALIZATION,
    compressionType = GZIP,
    reservedData = 0x00,
    extensionHeader = new Uint8Array()
  ): Uint8Array {
    // 正确计算headerSize
    const headerSize = Math.floor(extensionHeader.length / 4) + 1;
    const header = new Uint8Array(headerSize * 4);
    
    header[0] = (version << 4) | headerSize;
    header[1] = (messageType << 4) | messageTypeSpecificFlags;
    header[2] = (serialMethod << 4) | compressionType;
    header[3] = reservedData;
    
    if (extensionHeader.length > 0) {
      header.set(extensionHeader, 4);
    }
    
    return header;
  }

  /**
   * 压缩数据
   */
  private async compressData(data: Uint8Array): Promise<Uint8Array> {
    try {
      if ('CompressionStream' in window) {
        const compressionStream = new CompressionStream('gzip');
        const writer = compressionStream.writable.getWriter();
        const reader = compressionStream.readable.getReader();
        
        writer.write(data);
        writer.close();
        
        const chunks: Uint8Array[] = [];
        let done = false;
        
        while (!done) {
          const { value, done: streamDone } = await reader.read();
          done = streamDone;
          if (value) {
            chunks.push(value);
          }
        }
        
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          result.set(chunk, offset);
          offset += chunk.length;
        }
        
        return result;
      } else {
        console.warn('浏览器不支持GZIP压缩，使用原始数据');
        return data;
      }
    } catch (error) {
      console.error('GZIP压缩失败，使用原始数据:', error);
      return data;
    }
  }

  /**
   * 解压数据
   */
  private async decompressData(data: Uint8Array): Promise<Uint8Array> {
    try {
      if ('DecompressionStream' in window) {
        const decompressionStream = new DecompressionStream('gzip');
        const writer = decompressionStream.writable.getWriter();
        const reader = decompressionStream.readable.getReader();
        
        writer.write(data);
        writer.close();
        
        const chunks: Uint8Array[] = [];
        let done = false;
        
        while (!done) {
          const { value, done: streamDone } = await reader.read();
          done = streamDone;
          if (value) {
            chunks.push(value);
          }
        }
        
        const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
        const result = new Uint8Array(totalLength);
        let offset = 0;
        for (const chunk of chunks) {
          result.set(chunk, offset);
          offset += chunk.length;
        }
        
        return result;
      } else {
        return data;
      }
    } catch (error) {
      console.error('GZIP解压失败:', error);
      return data;
    }
  }

  private stringToUint8Array(str: string): Uint8Array {
    return new TextEncoder().encode(str);
  }

  private numberToBytes(num: number): Uint8Array {
    const buffer = new ArrayBuffer(4);
    const view = new DataView(buffer);
    view.setUint32(0, num, false); // false = 大端序
    return new Uint8Array(buffer);
  }

  /**
   * 处理接收到的消息
   */
  private async handleMessage(data: ArrayBuffer): Promise<void> {
    try {
      const response = await this.parseResponse(new Uint8Array(data));
      console.log('解析豆包响应:', {
        messageType: response.messageType,
        event: response.event,
        payloadType: typeof response.payloadMsg,
        payloadSize: response.payloadMsg instanceof Uint8Array ? response.payloadMsg.length : 'N/A'
      });
      
      if (response.messageType === 'SERVER_ACK' && response.payloadMsg instanceof Uint8Array) {
        // 音频数据
        console.log('收到音频数据:', response.payloadMsg.length, '字节');
        this.onEvent({
          type: 'audio',
          audio: response.payloadMsg.buffer as ArrayBuffer,
          timestamp: Date.now()
        });
      } else if (response.messageType === 'SERVER_FULL_RESPONSE') {
        console.log('收到完整响应, event:', response.event);
        
        if (response.event === 450) {
          console.log('收到清空缓存指令');
        }
        
        if (typeof response.payloadMsg === 'string') {
          console.log('收到转录文本:', response.payloadMsg);
          this.onEvent({
            type: 'transcript',
            text: response.payloadMsg,
            isFinal: true,
            timestamp: Date.now()
          });
        }
      } else if (response.messageType === 'SERVER_ERROR') {
        console.error('服务器错误:', response.payloadMsg);
        this.onEvent({
          type: 'error',
          error: response.payloadMsg as string,
          timestamp: Date.now()
        });
      }
    } catch (error) {
      console.error('处理消息失败:', error);
      this.onEvent({
        type: 'error',
        error: '消息处理失败',
        timestamp: Date.now()
      });
    }
  }

  /**
   * 解析服务器响应
   */
  private async parseResponse(data: Uint8Array): Promise<{
    messageType?: string;
    event?: number;
    payloadMsg?: unknown;
    sessionId?: string;
    code?: number;
    seq?: number;
  }> {
    if (data.length < 4) {
      throw new Error('数据长度不足');
    }

    const protocolVersion = data[0] >> 4;
    const headerSize = data[0] & 0x0f;
    const messageType = data[1] >> 4;
    const messageTypeSpecificFlags = data[1] & 0x0f;
    const serializationMethod = data[2] >> 4;
    const messageCompression = data[2] & 0x0f;
    
    console.log('解析响应头:', {
      protocolVersion,
      headerSize,
      messageType,
      messageTypeSpecificFlags,
      serializationMethod,
      messageCompression
    });
    
    const payload = data.slice(headerSize * 4);
    
    const result: {
      messageType?: string;
      event?: number;
      payloadMsg?: unknown;
      sessionId?: string;
      code?: number;
      seq?: number;
    } = {};
    
    let payloadMsg: unknown = null;
    let start = 0;
    
    if (messageType === SERVER_FULL_RESPONSE || messageType === SERVER_ACK) {
      result.messageType = messageType === SERVER_ACK ? 'SERVER_ACK' : 'SERVER_FULL_RESPONSE';
      
      if (messageTypeSpecificFlags & NEG_SEQUENCE) {
        const view = new DataView(payload.buffer, payload.byteOffset + start, 4);
        result.seq = view.getUint32(0, false);
        start += 4;
      }
      
      if (messageTypeSpecificFlags & MSG_WITH_EVENT) {
        const view = new DataView(payload.buffer, payload.byteOffset + start, 4);
        result.event = view.getUint32(0, false);
        start += 4;
      }
      
      const remainingPayload = payload.slice(start);
      if (remainingPayload.length >= 4) {
        const view = new DataView(remainingPayload.buffer, remainingPayload.byteOffset, 4);
        const sessionIdSize = view.getInt32(0, false);
        
        if (remainingPayload.length >= 4 + sessionIdSize + 4) {
          const sessionId = remainingPayload.slice(4, 4 + sessionIdSize);
          result.sessionId = new TextDecoder().decode(sessionId);
          
          const payloadSizeView = new DataView(remainingPayload.buffer, remainingPayload.byteOffset + 4 + sessionIdSize, 4);
          const payloadSize = payloadSizeView.getUint32(0, false);
          
          payloadMsg = remainingPayload.slice(4 + sessionIdSize + 4, 4 + sessionIdSize + 4 + payloadSize);
        }
      }
    } else if (messageType === SERVER_ERROR_RESPONSE) {
      result.messageType = 'SERVER_ERROR';
      const view = new DataView(payload.buffer, payload.byteOffset, 4);
      result.code = view.getUint32(0, false);
      
      const payloadSizeView = new DataView(payload.buffer, payload.byteOffset + 4, 4);
      const payloadSize = payloadSizeView.getUint32(0, false);
      
      payloadMsg = payload.slice(8, 8 + payloadSize);
    }
    
    // 处理压缩和序列化
    if (payloadMsg instanceof Uint8Array) {
      if (messageCompression === GZIP) {
        try {
          payloadMsg = await this.decompressData(payloadMsg);
        } catch (error) {
          console.warn('解压失败，使用原始数据:', error);
        }
      }
      
      if (serializationMethod === JSON_SERIALIZATION) {
        try {
          const text = new TextDecoder().decode(payloadMsg);
          payloadMsg = JSON.parse(text);
        } catch (error) {
          console.warn('JSON解析失败，使用原始文本:', error);
          payloadMsg = new TextDecoder().decode(payloadMsg);
        }
      } else if (serializationMethod !== NO_SERIALIZATION) {
        payloadMsg = new TextDecoder().decode(payloadMsg);
      }
    }
    
    result.payloadMsg = payloadMsg;
    return result;
  }

  /**
   * 关闭连接
   */
  async close(): Promise<void> {
    if (!this.ws) return;

    try {
      console.log('正在关闭WebSocket连接...');
      this.ws.close();
      this.isConnected = false;
    } catch (error) {
      console.error('关闭连接失败:', error);
    }
  }

  /**
   * 检查连接状态
   */
  isConnectionActive(): boolean {
    return this.isConnected && this.ws?.readyState === WebSocket.OPEN;
  }
}
```
## 总结

通过分析你的代码和豆包demo，我发现了以下主要问题：

### 主要问题：

1. **协议头大小计算错误** - `headerSize = 1` 应该是 `Math.floor(extensionHeader.length / 4) + 1`
2. **消息解析不完整** - 缺少正确的payload大小读取
3. **WebSocket代理实现不准确** - server.js中的协议实现有问题
4. **音频播放处理问题** - 没有正确处理PCM音频数据

### 解决方案：

1. **使用修复后的DoubaoVoiceClient** - 代理连接版本
2. **使用修复后的server.js** - 完整的协议实现
3. **使用修复后的VoiceCallManager** - 改进的音频处理

### 建议的测试步骤：

1. 启动修复后的服务器：`npm run dev`
2. 打开浏览器开发者工具，查看WebSocket连接日志
3. 尝试开始语音通话，观察连接状态和消息流
4. 检查是否能收到豆包的响应消息

### 调试建议：

1. **查看浏览器控制台** - 所有关键步骤都有详细日志
2. **检查网络面板** - 确认WebSocket连接状态
3. **监控服务器日志** - 查看代理服务器的处理过程

如果仍有问题，请提供：
- 浏览器控制台的错误日志
- 服务器端的日志输出
- 网络面板中的WebSocket消息详情

这样我可以进一步帮你定位问题。
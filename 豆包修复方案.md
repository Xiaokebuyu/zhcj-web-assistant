根据你提供的代码，我对比了 `doubaovoice_demo` 和你项目中的豆包语音集成，发现了几个关键问题：

## 主要问题分析

### 1. **WebSocket代理服务器headers缺失**

在 `server.js` 中，你的WebSocket代理缺少了关键的认证header：

```javascript
// 当前代码缺少 X-Api-App-Key
doubaoWs = new WebSocket('wss://openspeech.bytedance.com/api/v3/realtime/dialogue', {
  headers: {
    'X-Api-App-ID': '2139817228',
    'X-Api-Access-Key': 'LMxFTYn2mmWwQwmLfT3ZbwS4yj0JPiMt',
    'X-Api-Resource-Id': 'volc.speech.dialog',
    'X-Api-Connect-Id': Date.now().toString() + Math.random().toString(36).substr(2, 9)
  }
});
```

**应该添加:**
```javascript
'X-Api-App-Key': 'PlgvMymc7f3tQnJ6'  // 这个在demo中有，但你的代码中缺失
```

### 2. **协议实现问题**

你的 `doubaoVoiceClient.ts` 中协议头生成有问题：### 3. **连接初始化流程缺失**
```
// 修复后的协议头生成方法
private generateHeader(
  version = PROTOCOL_VERSION,
  messageType = CLIENT_FULL_REQUEST,
  messageTypeSpecificFlags = MSG_WITH_EVENT,
  serialMethod = JSON_SERIALIZATION,
  compressionType = GZIP,
  reservedData = 0x00,
  extensionHeader = new Uint8Array()
): Uint8Array {
  // 修复：header size 应该是字节数而不是4字节单位数
  const header = new Uint8Array(4 + extensionHeader.length);
  const headerSize = 1; // 固定为1，表示4字节的基础头部
  
  header[0] = (version << 4) | headerSize;  // 版本 + 头部大小
  header[1] = (messageType << 4) | messageTypeSpecificFlags;  // 消息类型 + 标志
  header[2] = (serialMethod << 4) | compressionType;  // 序列化 + 压缩
  header[3] = reservedData;  // 保留字段
  
  if (extensionHeader.length > 0) {
    header.set(extensionHeader, 4);
  }
  
  return header;
}
```
对比Python版本，你的连接流程缺少关键步骤：
```
/**
 * 建立WebSocket连接 - 修复版本
 */
async connect(): Promise<void> {
  return new Promise((resolve, reject) => {
    try {
      if (!this.config.baseUrl) {
        reject(new Error('WebSocket URL配置缺失'));
        return;
      }

      console.log('正在连接WebSocket代理服务器:', this.config.baseUrl);
      
      this.ws = new WebSocket(this.config.baseUrl);
      this.ws.binaryType = 'arraybuffer';

      let isInitialized = false;

      this.ws.onopen = async () => {
        console.log('WebSocket代理连接已建立，开始初始化豆包协议...');
        try {
          // 等待代理服务器连接豆包
          // 这里不需要发送初始化消息，代理服务器会处理
        } catch (error) {
          reject(error);
        }
      };

      this.ws.onmessage = async (event) => {
        try {
          if (typeof event.data === 'string') {
            const message = JSON.parse(event.data);
            
            switch (message.type) {
              case 'connected':
                if (!isInitialized) {
                  console.log('豆包服务连接成功，开始协议初始化...');
                  await this.initializeProtocol();
                  isInitialized = true;
                  this.isConnected = true;
                  resolve();
                }
                break;
                
              case 'error':
                console.error('代理服务器错误:', message.error);
                reject(new Error(message.error));
                break;
                
              case 'end':
                console.log('豆包服务连接已结束');
                this.isConnected = false;
                this.onEvent({ type: 'end', timestamp: Date.now() });
                break;
            }
          } else {
            // 处理豆包的二进制响应
            await this.handleMessage(event.data);
          }
        } catch (error) {
          console.error('处理WebSocket消息失败:', error);
          if (!isInitialized) {
            reject(error);
          }
        }
      };

      this.ws.onerror = (error) => {
        console.error('WebSocket连接错误:', error);
        reject(new Error('WebSocket连接失败'));
      };

      this.ws.onclose = (event) => {
        console.log('WebSocket连接已关闭, code:', event.code, 'reason:', event.reason);
        this.isConnected = false;
        this.onEvent({ type: 'end', timestamp: Date.now() });
      };

      // 连接超时
      setTimeout(() => {
        if (this.ws && this.ws.readyState === WebSocket.CONNECTING) {
          this.ws.close();
          reject(new Error('WebSocket连接超时'));
        }
      }, 10000);

    } catch (error) {
      reject(error);
    }
  });
}

/**
 * 初始化豆包协议 - 新增方法
 */
private async initializeProtocol(): Promise<void> {
  // 1. 发送StartConnection请求
  await this.sendStartConnection();
  
  // 等待响应
  await new Promise(resolve => setTimeout(resolve, 100));
  
  // 2. 发送StartSession请求
  await this.sendStartSession();
}

/**
 * 发送开始连接请求
 */
private async sendStartConnection(): Promise<void> {
  const header = this.generateHeader();
  const payload = this.stringToUint8Array('{}');
  const compressedPayload = await this.compressData(payload);
  
  const message = new Uint8Array(
    header.length + 4 + 4 + compressedPayload.length
  );
  
  let offset = 0;
  message.set(header, offset);
  offset += header.length;
  
  message.set(this.numberToBytes(1), offset); // StartConnection event
  offset += 4;
  
  message.set(this.numberToBytes(compressedPayload.length), offset);
  offset += 4;
  
  message.set(compressedPayload, offset);
  
  if (this.ws && this.ws.readyState === WebSocket.OPEN) {
    this.ws.send(message);
    console.log('已发送StartConnection请求');
  }
}

/**
 * 发送开始会话请求
 */
private async sendStartSession(): Promise<void> {
  const startSessionReq = {
    tts: {
      audio_config: {
        channel: 1,
        format: 'pcm',
        sample_rate: 24000
      }
    },
    dialog: {
      bot_name: '豆包'
    }
  };

  const header = this.generateHeader();
  const sessionIdBytes = this.stringToUint8Array(this.sessionId);
  const payload = this.stringToUint8Array(JSON.stringify(startSessionReq));
  const compressedPayload = await this.compressData(payload);
  
  const message = new Uint8Array(
    header.length + 4 + 4 + sessionIdBytes.length + 4 + compressedPayload.length
  );
  
  let offset = 0;
  message.set(header, offset);
  offset += header.length;
  
  message.set(this.numberToBytes(100), offset); // StartSession event
  offset += 4;
  
  message.set(this.numberToBytes(sessionIdBytes.length), offset);
  offset += 4;
  
  message.set(sessionIdBytes, offset);
  offset += sessionIdBytes.length;
  
  message.set(this.numberToBytes(compressedPayload.length), offset);
  offset += 4;
  
  message.set(compressedPayload, offset);
  
  if (this.ws && this.ws.readyState === WebSocket.OPEN) {
    this.ws.send(message);
    console.log('已发送StartSession请求');
  }
}
```
### 4. **修复WebSocket代理服务器**
```
const { createServer } = require('http');
const { parse } = require('url');
const next = require('next');
const WebSocket = require('ws');
const gzip = require('zlib');

const dev = process.env.NODE_ENV !== 'production';
const hostname = 'localhost';
const port = process.env.PORT || 3000;

const app = next({ dev, hostname, port });
const handle = app.getRequestHandler();

// 豆包协议常量
const PROTOCOL_VERSION = 0b0001;
const CLIENT_FULL_REQUEST = 0b0001;
const CLIENT_AUDIO_ONLY_REQUEST = 0b0010;
const MSG_WITH_EVENT = 0b0100;
const JSON_SERIALIZATION = 0b0001;
const GZIP = 0b0001;

// 生成协议头
function generateHeader(
  version = PROTOCOL_VERSION,
  messageType = CLIENT_FULL_REQUEST,
  messageTypeSpecificFlags = MSG_WITH_EVENT,
  serialMethod = JSON_SERIALIZATION,
  compressionType = GZIP,
  reservedData = 0x00
) {
  const header = Buffer.alloc(4);
  
  header[0] = (version << 4) | 0x01; // 版本 + 固定头部大小1
  header[1] = (messageType << 4) | messageTypeSpecificFlags;
  header[2] = (serialMethod << 4) | compressionType;
  header[3] = reservedData;
  
  return header;
}

// 数字转换为4字节大端序
function numberToBytes(num) {
  const buffer = Buffer.alloc(4);
  buffer.writeUInt32BE(num, 0);
  return buffer;
}

app.prepare().then(() => {
  const server = createServer(async (req, res) => {
    try {
      const parsedUrl = parse(req.url, true);
      await handle(req, res, parsedUrl);
    } catch (err) {
      console.error('Error occurred handling', req.url, err);
      res.statusCode = 500;
      res.end('internal server error');
    }
  });

  // 创建WebSocket服务器
  const wss = new WebSocket.Server({ 
    server,
    path: '/api/voice/realtime'
  });

  wss.on('connection', (ws, req) => {
    console.log('新的WebSocket连接');
    
    const url = parse(req.url, true);
    const sessionId = url.query.sessionId;
    
    if (!sessionId) {
      ws.close(1008, '缺少会话ID');
      return;
    }

    let doubaoWs = null;
    let isConnected = false;
    let isProtocolInitialized = false;

    // 连接到豆包服务
    const connectToDoubao = async () => {
      try {
        console.log('正在连接到豆包服务...');
        
        // 修复：添加完整的headers，包括缺失的X-Api-App-Key
        doubaoWs = new WebSocket('wss://openspeech.bytedance.com/api/v3/realtime/dialogue', {
          headers: {
            'X-Api-App-ID': '2139817228',
            'X-Api-Access-Key': 'LMxFTYn2mmWwQwmLfT3ZbwS4yj0JPiMt',
            'X-Api-Resource-Id': 'volc.speech.dialog',
            'X-Api-App-Key': 'PlgvMymc7f3tQnJ6', // 修复：添加缺失的App Key
            'X-Api-Connect-Id': Date.now().toString() + Math.random().toString(36).substr(2, 9)
          }
        });

        doubaoWs.on('open', async () => {
          console.log('豆包WebSocket连接已建立，开始协议初始化...');
          
          try {
            // 发送StartConnection请求
            await sendStartConnection();
            
            // 等待一下再发送StartSession
            setTimeout(async () => {
              await sendStartSession();
              isProtocolInitialized = true;
              isConnected = true;
              
              // 通知客户端连接成功
              ws.send(JSON.stringify({
                type: 'connected',
                sessionId: sessionId
              }));
              
            }, 200);
            
          } catch (error) {
            console.error('豆包协议初始化失败:', error);
            ws.send(JSON.stringify({
              type: 'error',
              error: '豆包服务初始化失败'
            }));
          }
        });

        // 发送StartConnection请求
        const sendStartConnection = async () => {
          const header = generateHeader();
          const payload = Buffer.from('{}');
          const compressedPayload = gzip.gzipSync(payload);
          
          const message = Buffer.concat([
            header,
            numberToBytes(1), // StartConnection event
            numberToBytes(compressedPayload.length),
            compressedPayload
          ]);
          
          doubaoWs.send(message);
          console.log('已发送StartConnection请求');
        };

        // 发送StartSession请求
        const sendStartSession = async () => {
          const startSessionReq = {
            tts: {
              audio_config: {
                channel: 1,
                format: 'pcm',
                sample_rate: 24000
              }
            },
            dialog: {
              bot_name: '豆包'
            }
          };

          const header = generateHeader();
          const sessionIdBytes = Buffer.from(sessionId);
          const payload = Buffer.from(JSON.stringify(startSessionReq));
          const compressedPayload = gzip.gzipSync(payload);
          
          const message = Buffer.concat([
            header,
            numberToBytes(100), // StartSession event
            numberToBytes(sessionIdBytes.length),
            sessionIdBytes,
            numberToBytes(compressedPayload.length),
            compressedPayload
          ]);
          
          doubaoWs.send(message);
          console.log('已发送StartSession请求');
        };

        doubaoWs.on('message', (data) => {
          try {
            // 转发豆包的消息到客户端
            ws.send(data);
          } catch (error) {
            console.error('转发豆包消息失败:', error);
          }
        });

        doubaoWs.on('error', (error) => {
          console.error('豆包WebSocket错误:', error);
          ws.send(JSON.stringify({
            type: 'error',
            error: '豆包服务连接错误: ' + error.message
          }));
        });

        doubaoWs.on('close', (code, reason) => {
          console.log('豆包WebSocket连接已关闭, code:', code, 'reason:', reason);
          isConnected = false;
          ws.send(JSON.stringify({
            type: 'end'
          }));
        });

      } catch (error) {
        console.error('连接豆包服务失败:', error);
        ws.send(JSON.stringify({
          type: 'error',
          error: '无法连接到豆包服务: ' + error.message
        }));
      }
    };

    // 处理客户端消息
    ws.on('message', (message) => {
      try {
        if (doubaoWs && isConnected && isProtocolInitialized && doubaoWs.readyState === WebSocket.OPEN) {
          // 转发客户端消息到豆包
          doubaoWs.send(message);
        } else {
          console.warn('豆包连接未就绪，忽略客户端消息');
        }
      } catch (error) {
        console.error('转发客户端消息失败:', error);
      }
    });

    ws.on('close', () => {
      console.log('客户端WebSocket连接已关闭');
      
      // 发送FinishSession和FinishConnection
      if (doubaoWs && doubaoWs.readyState === WebSocket.OPEN) {
        try {
          // 发送FinishSession
          const finishSessionHeader = generateHeader();
          const sessionIdBytes = Buffer.from(sessionId);
          const payload = Buffer.from('{}');
          const compressedPayload = gzip.gzipSync(payload);
          
          const finishSessionMessage = Buffer.concat([
            finishSessionHeader,
            numberToBytes(102), // FinishSession event
            numberToBytes(sessionIdBytes.length),
            sessionIdBytes,
            numberToBytes(compressedPayload.length),
            compressedPayload
          ]);
          
          doubaoWs.send(finishSessionMessage);
          
          setTimeout(() => {
            // 发送FinishConnection
            const finishConnectionHeader = generateHeader();
            const finishPayload = Buffer.from('{}');
            const compressedFinishPayload = gzip.gzipSync(finishPayload);
            
            const finishConnectionMessage = Buffer.concat([
              finishConnectionHeader,
              numberToBytes(2), // FinishConnection event
              numberToBytes(compressedFinishPayload.length),
              compressedFinishPayload
            ]);
            
            doubaoWs.send(finishConnectionMessage);
            
            setTimeout(() => {
              doubaoWs.close();
            }, 100);
            
          }, 100);
          
        } catch (error) {
          console.error('发送结束请求失败:', error);
          doubaoWs.close();
        }
      }
    });

    ws.on('error', (error) => {
      console.error('客户端WebSocket错误:', error);
      if (doubaoWs && doubaoWs.readyState === WebSocket.OPEN) {
        doubaoWs.close();
      }
    });

    // 开始连接到豆包
    connectToDoubao();
  });

  server.listen(port, (err) => {
    if (err) throw err;
    console.log(`> Ready on http://${hostname}:${port}`);
    console.log('> WebSocket代理服务器已启动在 /api/voice/realtime');
  });
});
```
### 5. **音频处理器优化**
```
/**
 * 音频处理器关键方法修复版本
 */

/**
 * 修复：改进的PCM转换方法，确保与豆包兼容
 */
private convertToPCM(float32Array: Float32Array): Int16Array {
  const int16Array = new Int16Array(float32Array.length);
  for (let i = 0; i < float32Array.length; i++) {
    // 限制到[-1, 1]范围
    let sample = Math.max(-1, Math.min(1, float32Array[i]));
    
    // 转换为16位整数，使用正确的范围
    if (sample < 0) {
      int16Array[i] = Math.floor(sample * 0x8000); // -32768
    } else {
      int16Array[i] = Math.floor(sample * 0x7FFF); // 32767
    }
  }
  return int16Array;
}

/**
 * 修复：改进的音频捕获启动方法
 */
async startCapture(
  onAudioData: (audioData: ArrayBuffer) => void,
  onSilenceDetected?: (duration: number) => void,
  onVisualizationData?: (data: AudioVisualizationData) => void
): Promise<void> {
  if (this.isRecording) {
    throw new Error('音频捕获已在进行中');
  }

  this.onAudioData = onAudioData;
  this.onSilenceDetected = onSilenceDetected || null;
  this.onVisualizationData = onVisualizationData || null;

  try {
    // 检查浏览器支持
    const support = AudioProcessor.checkSupport();
    if (!support.mediaDevices) {
      throw new Error('浏览器不支持MediaDevices API，无法访问麦克风');
    }
    if (!support.audioContext) {
      throw new Error('浏览器不支持Web Audio API');
    }

    console.log('正在请求麦克风权限...');
    
    // 修复：使用更兼容的音频约束
    this.mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate: { ideal: this.sampleRate },
        channelCount: { exact: this.channels },
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        // 添加延迟优化
        latency: { ideal: 0.01 }
      }
    });

    console.log('麦克风权限获取成功');

    if (!this.audioContext || !this.analyserNode) {
      await this.initializeAudioContext();
    }

    // 修复：确保音频上下文处于运行状态
    if (this.audioContext!.state === 'suspended') {
      console.log('正在恢复音频上下文...');
      await this.audioContext!.resume();
    }

    // 创建源节点
    this.sourceNode = this.audioContext!.createMediaStreamSource(this.mediaStream);
    
    // 修复：使用更小的缓冲区大小以减少延迟
    const bufferSize = 2048; // 减小缓冲区大小
    this.scriptProcessorNode = this.audioContext!.createScriptProcessor(
      bufferSize, 
      this.channels, 
      this.channels
    );

    // 连接音频节点
    this.sourceNode.connect(this.analyserNode!);
    this.analyserNode!.connect(this.scriptProcessorNode);
    this.scriptProcessorNode.connect(this.audioContext!.destination);

    // 设置音频处理回调
    this.scriptProcessorNode.onaudioprocess = (event) => {
      try {
        this.processAudioData(event);
      } catch (error) {
        console.error('音频数据处理失败:', error);
      }
    };

    this.isRecording = true;
    this.silenceStartTime = Date.now();
    
    console.log('音频捕获已开始，采样率:', this.audioContext!.sampleRate);

  } catch (error) {
    console.error('开始音频捕获失败:', error);
    this.cleanup();
    
    // 提供更具体的错误信息
    if (error instanceof Error) {
      if (error.name === 'NotAllowedError') {
        throw new Error('麦克风权限被拒绝，请在浏览器设置中允许访问麦克风');
      } else if (error.name === 'NotFoundError') {
        throw new Error('未找到可用的麦克风设备');
      } else if (error.name === 'NotSupportedError') {
        throw new Error('当前浏览器不支持音频捕获');
      } else if (error.name === 'NotReadableError') {
        throw new Error('麦克风设备被其他应用占用');
      } else {
        throw new Error(`音频捕获失败: ${error.message}`);
      }
    } else {
      throw new Error('音频捕获失败: 未知错误');
    }
  }
}

/**
 * 修复：改进的音频数据处理方法
 */
private processAudioData(event: AudioProcessingEvent): void {
  if (!this.isRecording || !this.onAudioData) return;

  const inputBuffer = event.inputBuffer;
  const channelData = inputBuffer.getChannelData(0);

  // 修复：重采样到目标采样率（如果需要）
  let processedData = channelData;
  if (inputBuffer.sampleRate !== this.sampleRate) {
    processedData = this.resampleAudio(channelData, inputBuffer.sampleRate, this.sampleRate);
  }

  // 计算音量用于静音检测
  const volume = this.calculateVolume(processedData);

  // 静音检测
  if (volume < this.silenceThreshold) {
    if (this.silenceStartTime === 0) {
      this.silenceStartTime = Date.now();
    } else {
      const silenceDuration = Date.now() - this.silenceStartTime;
      if (this.onSilenceDetected && silenceDuration > 1000) {
        this.onSilenceDetected(silenceDuration);
      }
    }
  } else {
    this.silenceStartTime = 0;
  }

  // 生成可视化数据
  if (this.onVisualizationData && this.analyserNode) {
    const visualizationData = this.generateVisualizationData(volume);
    this.onVisualizationData(visualizationData);
  }

  // 转换为PCM格式并发送
  const pcmData = this.convertToPCM(processedData);
  this.onAudioData(pcmData.buffer as ArrayBuffer);
}

/**
 * 新增：简单的重采样方法
 */
private resampleAudio(input: Float32Array, inputRate: number, outputRate: number): Float32Array {
  if (inputRate === outputRate) {
    return input;
  }

  const ratio = inputRate / outputRate;
  const outputLength = Math.floor(input.length / ratio);
  const output = new Float32Array(outputLength);

  for (let i = 0; i < outputLength; i++) {
    const sourceIndex = i * ratio;
    const index = Math.floor(sourceIndex);
    const fraction = sourceIndex - index;

    if (index + 1 < input.length) {
      // 线性插值
      output[i] = input[index] * (1 - fraction) + input[index + 1] * fraction;
    } else {
      output[i] = input[index];
    }
  }

  return output;
}
```
### 6. **压缩问题修复**
```
/**
 * 修复后的压缩/解压方法
 */

/**
 * 压缩数据 - 修复版本，兼容性更好
 */
private async compressData(data: Uint8Array): Promise<Uint8Array> {
  try {
    // 优先使用CompressionStream（较新的浏览器）
    if ('CompressionStream' in window) {
      const stream = new CompressionStream('gzip');
      const writer = stream.writable.getWriter();
      const reader = stream.readable.getReader();
      
      // 写入数据
      await writer.write(data);
      await writer.close();
      
      // 读取压缩后的数据
      const chunks: Uint8Array[] = [];
      let done = false;
      
      while (!done) {
        const { value, done: streamDone } = await reader.read();
        done = streamDone;
        if (value) {
          chunks.push(value);
        }
      }
      
      // 合并chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result;
    } 
    // 降级方案：如果不支持CompressionStream，返回原始数据
    else {
      console.warn('CompressionStream not supported, sending uncompressed data');
      // 添加简单的标记，表明这是未压缩的数据
      return data;
    }
  } catch (error) {
    console.error('Compression failed:', error);
    // 压缩失败时返回原始数据
    return data;
  }
}

/**
 * 解压数据 - 修复版本
 */
private async decompressData(data: Uint8Array): Promise<Uint8Array> {
  try {
    if ('DecompressionStream' in window) {
      const stream = new DecompressionStream('gzip');
      const writer = stream.writable.getWriter();
      const reader = stream.readable.getReader();
      
      await writer.write(data);
      await writer.close();
      
      const chunks: Uint8Array[] = [];
      let done = false;
      
      while (!done) {
        const { value, done: streamDone } = await reader.read();
        done = streamDone;
        if (value) {
          chunks.push(value);
        }
      }
      
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result;
    } else {
      // 如果不支持DecompressionStream，假设数据未压缩
      return data;
    }
  } catch (error) {
    console.error('Decompression failed:', error);
    // 解压失败时返回原始数据
    return data;
  }
}
```
## 完整修复方案总结

根据分析，你的豆包语音集成主要存在以下问题：

### 🔧 **立即需要修复的问题**

1. **WebSocket代理服务器headers缺失** ❌
   - 缺少 `X-Api-App-Key: 'PlgvMymc7f3tQnJ6'`
   - 需要完整的协议初始化流程

2. **协议实现不完整** ❌  
   - 缺少StartConnection和StartSession步骤
   - 头部生成算法有误
   - 缺少正确的结束流程

3. **音频处理问题** ❌
   - PCM格式转换可能有精度问题
   - 采样率处理不当
   - 缺少重采样功能

4. **压缩兼容性问题** ❌
   - CompressionStream API兼容性处理不当

### 📋 **修复步骤**

1. **替换 `server.js`** - 使用修复后的版本，添加完整headers和协议流程
2. **更新 `doubaoVoiceClient.ts`** - 添加正确的连接初始化流程
3. **优化 `audioProcessor.ts`** - 改进PCM转换和重采样
4. **测试连接流程** - 确保完整的协议握手

### 🚀 **验证修复效果**

修复后，你应该看到以下日志输出：
```
> WebSocket代理连接已建立，开始协议初始化...
> 已发送StartConnection请求  
> 已发送StartSession请求
> 豆包服务连接成功
> 音频捕获已开始，采样率: 16000
```

### ⚠️ **注意事项**

1. **确保使用最新的Chrome/Firefox/Edge浏览器**
2. **在HTTPS环境下测试** - HTTP可能有安全限制
3. **检查麦克风权限** - 确保用户授权
4. **监控WebSocket连接状态** - 添加重连机制

按照这些修复方案，你的豆包语音通话功能应该能够正常工作了！
æ ¹æ®ä½ æä¾›çš„ä»£ç ï¼Œæˆ‘å¯¹æ¯”äº† `doubaovoice_demo` å’Œä½ é¡¹ç›®ä¸­çš„è±†åŒ…è¯­éŸ³é›†æˆï¼Œå‘ç°äº†å‡ ä¸ªå…³é”®é—®é¢˜ï¼š

## ä¸»è¦é—®é¢˜åˆ†æ

### 1. **WebSocketä»£ç†æœåŠ¡å™¨headersç¼ºå¤±**

åœ¨ `server.js` ä¸­ï¼Œä½ çš„WebSocketä»£ç†ç¼ºå°‘äº†å…³é”®çš„è®¤è¯headerï¼š

```javascript
// å½“å‰ä»£ç ç¼ºå°‘ X-Api-App-Key
doubaoWs = new WebSocket('wss://openspeech.bytedance.com/api/v3/realtime/dialogue', {
  headers: {
    'X-Api-App-ID': '2139817228',
    'X-Api-Access-Key': 'LMxFTYn2mmWwQwmLfT3ZbwS4yj0JPiMt',
    'X-Api-Resource-Id': 'volc.speech.dialog',
    'X-Api-Connect-Id': Date.now().toString() + Math.random().toString(36).substr(2, 9)
  }
});
```

**åº”è¯¥æ·»åŠ :**
```javascript
'X-Api-App-Key': 'PlgvMymc7f3tQnJ6'  // è¿™ä¸ªåœ¨demoä¸­æœ‰ï¼Œä½†ä½ çš„ä»£ç ä¸­ç¼ºå¤±
```

### 2. **åè®®å®ç°é—®é¢˜**

ä½ çš„ `doubaoVoiceClient.ts` ä¸­åè®®å¤´ç”Ÿæˆæœ‰é—®é¢˜ï¼š### 3. **è¿æ¥åˆå§‹åŒ–æµç¨‹ç¼ºå¤±**
```
// ä¿®å¤åçš„åè®®å¤´ç”Ÿæˆæ–¹æ³•
private generateHeader(
  version = PROTOCOL_VERSION,
  messageType = CLIENT_FULL_REQUEST,
  messageTypeSpecificFlags = MSG_WITH_EVENT,
  serialMethod = JSON_SERIALIZATION,
  compressionType = GZIP,
  reservedData = 0x00,
  extensionHeader = new Uint8Array()
): Uint8Array {
  // ä¿®å¤ï¼šheader size åº”è¯¥æ˜¯å­—èŠ‚æ•°è€Œä¸æ˜¯4å­—èŠ‚å•ä½æ•°
  const header = new Uint8Array(4 + extensionHeader.length);
  const headerSize = 1; // å›ºå®šä¸º1ï¼Œè¡¨ç¤º4å­—èŠ‚çš„åŸºç¡€å¤´éƒ¨
  
  header[0] = (version << 4) | headerSize;  // ç‰ˆæœ¬ + å¤´éƒ¨å¤§å°
  header[1] = (messageType << 4) | messageTypeSpecificFlags;  // æ¶ˆæ¯ç±»å‹ + æ ‡å¿—
  header[2] = (serialMethod << 4) | compressionType;  // åºåˆ—åŒ– + å‹ç¼©
  header[3] = reservedData;  // ä¿ç•™å­—æ®µ
  
  if (extensionHeader.length > 0) {
    header.set(extensionHeader, 4);
  }
  
  return header;
}
```
å¯¹æ¯”Pythonç‰ˆæœ¬ï¼Œä½ çš„è¿æ¥æµç¨‹ç¼ºå°‘å…³é”®æ­¥éª¤ï¼š
```
/**
 * å»ºç«‹WebSocketè¿æ¥ - ä¿®å¤ç‰ˆæœ¬
 */
async connect(): Promise<void> {
  return new Promise((resolve, reject) => {
    try {
      if (!this.config.baseUrl) {
        reject(new Error('WebSocket URLé…ç½®ç¼ºå¤±'));
        return;
      }

      console.log('æ­£åœ¨è¿æ¥WebSocketä»£ç†æœåŠ¡å™¨:', this.config.baseUrl);
      
      this.ws = new WebSocket(this.config.baseUrl);
      this.ws.binaryType = 'arraybuffer';

      let isInitialized = false;

      this.ws.onopen = async () => {
        console.log('WebSocketä»£ç†è¿æ¥å·²å»ºç«‹ï¼Œå¼€å§‹åˆå§‹åŒ–è±†åŒ…åè®®...');
        try {
          // ç­‰å¾…ä»£ç†æœåŠ¡å™¨è¿æ¥è±†åŒ…
          // è¿™é‡Œä¸éœ€è¦å‘é€åˆå§‹åŒ–æ¶ˆæ¯ï¼Œä»£ç†æœåŠ¡å™¨ä¼šå¤„ç†
        } catch (error) {
          reject(error);
        }
      };

      this.ws.onmessage = async (event) => {
        try {
          if (typeof event.data === 'string') {
            const message = JSON.parse(event.data);
            
            switch (message.type) {
              case 'connected':
                if (!isInitialized) {
                  console.log('è±†åŒ…æœåŠ¡è¿æ¥æˆåŠŸï¼Œå¼€å§‹åè®®åˆå§‹åŒ–...');
                  await this.initializeProtocol();
                  isInitialized = true;
                  this.isConnected = true;
                  resolve();
                }
                break;
                
              case 'error':
                console.error('ä»£ç†æœåŠ¡å™¨é”™è¯¯:', message.error);
                reject(new Error(message.error));
                break;
                
              case 'end':
                console.log('è±†åŒ…æœåŠ¡è¿æ¥å·²ç»“æŸ');
                this.isConnected = false;
                this.onEvent({ type: 'end', timestamp: Date.now() });
                break;
            }
          } else {
            // å¤„ç†è±†åŒ…çš„äºŒè¿›åˆ¶å“åº”
            await this.handleMessage(event.data);
          }
        } catch (error) {
          console.error('å¤„ç†WebSocketæ¶ˆæ¯å¤±è´¥:', error);
          if (!isInitialized) {
            reject(error);
          }
        }
      };

      this.ws.onerror = (error) => {
        console.error('WebSocketè¿æ¥é”™è¯¯:', error);
        reject(new Error('WebSocketè¿æ¥å¤±è´¥'));
      };

      this.ws.onclose = (event) => {
        console.log('WebSocketè¿æ¥å·²å…³é—­, code:', event.code, 'reason:', event.reason);
        this.isConnected = false;
        this.onEvent({ type: 'end', timestamp: Date.now() });
      };

      // è¿æ¥è¶…æ—¶
      setTimeout(() => {
        if (this.ws && this.ws.readyState === WebSocket.CONNECTING) {
          this.ws.close();
          reject(new Error('WebSocketè¿æ¥è¶…æ—¶'));
        }
      }, 10000);

    } catch (error) {
      reject(error);
    }
  });
}

/**
 * åˆå§‹åŒ–è±†åŒ…åè®® - æ–°å¢æ–¹æ³•
 */
private async initializeProtocol(): Promise<void> {
  // 1. å‘é€StartConnectionè¯·æ±‚
  await this.sendStartConnection();
  
  // ç­‰å¾…å“åº”
  await new Promise(resolve => setTimeout(resolve, 100));
  
  // 2. å‘é€StartSessionè¯·æ±‚
  await this.sendStartSession();
}

/**
 * å‘é€å¼€å§‹è¿æ¥è¯·æ±‚
 */
private async sendStartConnection(): Promise<void> {
  const header = this.generateHeader();
  const payload = this.stringToUint8Array('{}');
  const compressedPayload = await this.compressData(payload);
  
  const message = new Uint8Array(
    header.length + 4 + 4 + compressedPayload.length
  );
  
  let offset = 0;
  message.set(header, offset);
  offset += header.length;
  
  message.set(this.numberToBytes(1), offset); // StartConnection event
  offset += 4;
  
  message.set(this.numberToBytes(compressedPayload.length), offset);
  offset += 4;
  
  message.set(compressedPayload, offset);
  
  if (this.ws && this.ws.readyState === WebSocket.OPEN) {
    this.ws.send(message);
    console.log('å·²å‘é€StartConnectionè¯·æ±‚');
  }
}

/**
 * å‘é€å¼€å§‹ä¼šè¯è¯·æ±‚
 */
private async sendStartSession(): Promise<void> {
  const startSessionReq = {
    tts: {
      audio_config: {
        channel: 1,
        format: 'pcm',
        sample_rate: 24000
      }
    },
    dialog: {
      bot_name: 'è±†åŒ…'
    }
  };

  const header = this.generateHeader();
  const sessionIdBytes = this.stringToUint8Array(this.sessionId);
  const payload = this.stringToUint8Array(JSON.stringify(startSessionReq));
  const compressedPayload = await this.compressData(payload);
  
  const message = new Uint8Array(
    header.length + 4 + 4 + sessionIdBytes.length + 4 + compressedPayload.length
  );
  
  let offset = 0;
  message.set(header, offset);
  offset += header.length;
  
  message.set(this.numberToBytes(100), offset); // StartSession event
  offset += 4;
  
  message.set(this.numberToBytes(sessionIdBytes.length), offset);
  offset += 4;
  
  message.set(sessionIdBytes, offset);
  offset += sessionIdBytes.length;
  
  message.set(this.numberToBytes(compressedPayload.length), offset);
  offset += 4;
  
  message.set(compressedPayload, offset);
  
  if (this.ws && this.ws.readyState === WebSocket.OPEN) {
    this.ws.send(message);
    console.log('å·²å‘é€StartSessionè¯·æ±‚');
  }
}
```
### 4. **ä¿®å¤WebSocketä»£ç†æœåŠ¡å™¨**
```
const { createServer } = require('http');
const { parse } = require('url');
const next = require('next');
const WebSocket = require('ws');
const gzip = require('zlib');

const dev = process.env.NODE_ENV !== 'production';
const hostname = 'localhost';
const port = process.env.PORT || 3000;

const app = next({ dev, hostname, port });
const handle = app.getRequestHandler();

// è±†åŒ…åè®®å¸¸é‡
const PROTOCOL_VERSION = 0b0001;
const CLIENT_FULL_REQUEST = 0b0001;
const CLIENT_AUDIO_ONLY_REQUEST = 0b0010;
const MSG_WITH_EVENT = 0b0100;
const JSON_SERIALIZATION = 0b0001;
const GZIP = 0b0001;

// ç”Ÿæˆåè®®å¤´
function generateHeader(
  version = PROTOCOL_VERSION,
  messageType = CLIENT_FULL_REQUEST,
  messageTypeSpecificFlags = MSG_WITH_EVENT,
  serialMethod = JSON_SERIALIZATION,
  compressionType = GZIP,
  reservedData = 0x00
) {
  const header = Buffer.alloc(4);
  
  header[0] = (version << 4) | 0x01; // ç‰ˆæœ¬ + å›ºå®šå¤´éƒ¨å¤§å°1
  header[1] = (messageType << 4) | messageTypeSpecificFlags;
  header[2] = (serialMethod << 4) | compressionType;
  header[3] = reservedData;
  
  return header;
}

// æ•°å­—è½¬æ¢ä¸º4å­—èŠ‚å¤§ç«¯åº
function numberToBytes(num) {
  const buffer = Buffer.alloc(4);
  buffer.writeUInt32BE(num, 0);
  return buffer;
}

app.prepare().then(() => {
  const server = createServer(async (req, res) => {
    try {
      const parsedUrl = parse(req.url, true);
      await handle(req, res, parsedUrl);
    } catch (err) {
      console.error('Error occurred handling', req.url, err);
      res.statusCode = 500;
      res.end('internal server error');
    }
  });

  // åˆ›å»ºWebSocketæœåŠ¡å™¨
  const wss = new WebSocket.Server({ 
    server,
    path: '/api/voice/realtime'
  });

  wss.on('connection', (ws, req) => {
    console.log('æ–°çš„WebSocketè¿æ¥');
    
    const url = parse(req.url, true);
    const sessionId = url.query.sessionId;
    
    if (!sessionId) {
      ws.close(1008, 'ç¼ºå°‘ä¼šè¯ID');
      return;
    }

    let doubaoWs = null;
    let isConnected = false;
    let isProtocolInitialized = false;

    // è¿æ¥åˆ°è±†åŒ…æœåŠ¡
    const connectToDoubao = async () => {
      try {
        console.log('æ­£åœ¨è¿æ¥åˆ°è±†åŒ…æœåŠ¡...');
        
        // ä¿®å¤ï¼šæ·»åŠ å®Œæ•´çš„headersï¼ŒåŒ…æ‹¬ç¼ºå¤±çš„X-Api-App-Key
        doubaoWs = new WebSocket('wss://openspeech.bytedance.com/api/v3/realtime/dialogue', {
          headers: {
            'X-Api-App-ID': '2139817228',
            'X-Api-Access-Key': 'LMxFTYn2mmWwQwmLfT3ZbwS4yj0JPiMt',
            'X-Api-Resource-Id': 'volc.speech.dialog',
            'X-Api-App-Key': 'PlgvMymc7f3tQnJ6', // ä¿®å¤ï¼šæ·»åŠ ç¼ºå¤±çš„App Key
            'X-Api-Connect-Id': Date.now().toString() + Math.random().toString(36).substr(2, 9)
          }
        });

        doubaoWs.on('open', async () => {
          console.log('è±†åŒ…WebSocketè¿æ¥å·²å»ºç«‹ï¼Œå¼€å§‹åè®®åˆå§‹åŒ–...');
          
          try {
            // å‘é€StartConnectionè¯·æ±‚
            await sendStartConnection();
            
            // ç­‰å¾…ä¸€ä¸‹å†å‘é€StartSession
            setTimeout(async () => {
              await sendStartSession();
              isProtocolInitialized = true;
              isConnected = true;
              
              // é€šçŸ¥å®¢æˆ·ç«¯è¿æ¥æˆåŠŸ
              ws.send(JSON.stringify({
                type: 'connected',
                sessionId: sessionId
              }));
              
            }, 200);
            
          } catch (error) {
            console.error('è±†åŒ…åè®®åˆå§‹åŒ–å¤±è´¥:', error);
            ws.send(JSON.stringify({
              type: 'error',
              error: 'è±†åŒ…æœåŠ¡åˆå§‹åŒ–å¤±è´¥'
            }));
          }
        });

        // å‘é€StartConnectionè¯·æ±‚
        const sendStartConnection = async () => {
          const header = generateHeader();
          const payload = Buffer.from('{}');
          const compressedPayload = gzip.gzipSync(payload);
          
          const message = Buffer.concat([
            header,
            numberToBytes(1), // StartConnection event
            numberToBytes(compressedPayload.length),
            compressedPayload
          ]);
          
          doubaoWs.send(message);
          console.log('å·²å‘é€StartConnectionè¯·æ±‚');
        };

        // å‘é€StartSessionè¯·æ±‚
        const sendStartSession = async () => {
          const startSessionReq = {
            tts: {
              audio_config: {
                channel: 1,
                format: 'pcm',
                sample_rate: 24000
              }
            },
            dialog: {
              bot_name: 'è±†åŒ…'
            }
          };

          const header = generateHeader();
          const sessionIdBytes = Buffer.from(sessionId);
          const payload = Buffer.from(JSON.stringify(startSessionReq));
          const compressedPayload = gzip.gzipSync(payload);
          
          const message = Buffer.concat([
            header,
            numberToBytes(100), // StartSession event
            numberToBytes(sessionIdBytes.length),
            sessionIdBytes,
            numberToBytes(compressedPayload.length),
            compressedPayload
          ]);
          
          doubaoWs.send(message);
          console.log('å·²å‘é€StartSessionè¯·æ±‚');
        };

        doubaoWs.on('message', (data) => {
          try {
            // è½¬å‘è±†åŒ…çš„æ¶ˆæ¯åˆ°å®¢æˆ·ç«¯
            ws.send(data);
          } catch (error) {
            console.error('è½¬å‘è±†åŒ…æ¶ˆæ¯å¤±è´¥:', error);
          }
        });

        doubaoWs.on('error', (error) => {
          console.error('è±†åŒ…WebSocketé”™è¯¯:', error);
          ws.send(JSON.stringify({
            type: 'error',
            error: 'è±†åŒ…æœåŠ¡è¿æ¥é”™è¯¯: ' + error.message
          }));
        });

        doubaoWs.on('close', (code, reason) => {
          console.log('è±†åŒ…WebSocketè¿æ¥å·²å…³é—­, code:', code, 'reason:', reason);
          isConnected = false;
          ws.send(JSON.stringify({
            type: 'end'
          }));
        });

      } catch (error) {
        console.error('è¿æ¥è±†åŒ…æœåŠ¡å¤±è´¥:', error);
        ws.send(JSON.stringify({
          type: 'error',
          error: 'æ— æ³•è¿æ¥åˆ°è±†åŒ…æœåŠ¡: ' + error.message
        }));
      }
    };

    // å¤„ç†å®¢æˆ·ç«¯æ¶ˆæ¯
    ws.on('message', (message) => {
      try {
        if (doubaoWs && isConnected && isProtocolInitialized && doubaoWs.readyState === WebSocket.OPEN) {
          // è½¬å‘å®¢æˆ·ç«¯æ¶ˆæ¯åˆ°è±†åŒ…
          doubaoWs.send(message);
        } else {
          console.warn('è±†åŒ…è¿æ¥æœªå°±ç»ªï¼Œå¿½ç•¥å®¢æˆ·ç«¯æ¶ˆæ¯');
        }
      } catch (error) {
        console.error('è½¬å‘å®¢æˆ·ç«¯æ¶ˆæ¯å¤±è´¥:', error);
      }
    });

    ws.on('close', () => {
      console.log('å®¢æˆ·ç«¯WebSocketè¿æ¥å·²å…³é—­');
      
      // å‘é€FinishSessionå’ŒFinishConnection
      if (doubaoWs && doubaoWs.readyState === WebSocket.OPEN) {
        try {
          // å‘é€FinishSession
          const finishSessionHeader = generateHeader();
          const sessionIdBytes = Buffer.from(sessionId);
          const payload = Buffer.from('{}');
          const compressedPayload = gzip.gzipSync(payload);
          
          const finishSessionMessage = Buffer.concat([
            finishSessionHeader,
            numberToBytes(102), // FinishSession event
            numberToBytes(sessionIdBytes.length),
            sessionIdBytes,
            numberToBytes(compressedPayload.length),
            compressedPayload
          ]);
          
          doubaoWs.send(finishSessionMessage);
          
          setTimeout(() => {
            // å‘é€FinishConnection
            const finishConnectionHeader = generateHeader();
            const finishPayload = Buffer.from('{}');
            const compressedFinishPayload = gzip.gzipSync(finishPayload);
            
            const finishConnectionMessage = Buffer.concat([
              finishConnectionHeader,
              numberToBytes(2), // FinishConnection event
              numberToBytes(compressedFinishPayload.length),
              compressedFinishPayload
            ]);
            
            doubaoWs.send(finishConnectionMessage);
            
            setTimeout(() => {
              doubaoWs.close();
            }, 100);
            
          }, 100);
          
        } catch (error) {
          console.error('å‘é€ç»“æŸè¯·æ±‚å¤±è´¥:', error);
          doubaoWs.close();
        }
      }
    });

    ws.on('error', (error) => {
      console.error('å®¢æˆ·ç«¯WebSocketé”™è¯¯:', error);
      if (doubaoWs && doubaoWs.readyState === WebSocket.OPEN) {
        doubaoWs.close();
      }
    });

    // å¼€å§‹è¿æ¥åˆ°è±†åŒ…
    connectToDoubao();
  });

  server.listen(port, (err) => {
    if (err) throw err;
    console.log(`> Ready on http://${hostname}:${port}`);
    console.log('> WebSocketä»£ç†æœåŠ¡å™¨å·²å¯åŠ¨åœ¨ /api/voice/realtime');
  });
});
```
### 5. **éŸ³é¢‘å¤„ç†å™¨ä¼˜åŒ–**
```
/**
 * éŸ³é¢‘å¤„ç†å™¨å…³é”®æ–¹æ³•ä¿®å¤ç‰ˆæœ¬
 */

/**
 * ä¿®å¤ï¼šæ”¹è¿›çš„PCMè½¬æ¢æ–¹æ³•ï¼Œç¡®ä¿ä¸è±†åŒ…å…¼å®¹
 */
private convertToPCM(float32Array: Float32Array): Int16Array {
  const int16Array = new Int16Array(float32Array.length);
  for (let i = 0; i < float32Array.length; i++) {
    // é™åˆ¶åˆ°[-1, 1]èŒƒå›´
    let sample = Math.max(-1, Math.min(1, float32Array[i]));
    
    // è½¬æ¢ä¸º16ä½æ•´æ•°ï¼Œä½¿ç”¨æ­£ç¡®çš„èŒƒå›´
    if (sample < 0) {
      int16Array[i] = Math.floor(sample * 0x8000); // -32768
    } else {
      int16Array[i] = Math.floor(sample * 0x7FFF); // 32767
    }
  }
  return int16Array;
}

/**
 * ä¿®å¤ï¼šæ”¹è¿›çš„éŸ³é¢‘æ•è·å¯åŠ¨æ–¹æ³•
 */
async startCapture(
  onAudioData: (audioData: ArrayBuffer) => void,
  onSilenceDetected?: (duration: number) => void,
  onVisualizationData?: (data: AudioVisualizationData) => void
): Promise<void> {
  if (this.isRecording) {
    throw new Error('éŸ³é¢‘æ•è·å·²åœ¨è¿›è¡Œä¸­');
  }

  this.onAudioData = onAudioData;
  this.onSilenceDetected = onSilenceDetected || null;
  this.onVisualizationData = onVisualizationData || null;

  try {
    // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
    const support = AudioProcessor.checkSupport();
    if (!support.mediaDevices) {
      throw new Error('æµè§ˆå™¨ä¸æ”¯æŒMediaDevices APIï¼Œæ— æ³•è®¿é—®éº¦å…‹é£');
    }
    if (!support.audioContext) {
      throw new Error('æµè§ˆå™¨ä¸æ”¯æŒWeb Audio API');
    }

    console.log('æ­£åœ¨è¯·æ±‚éº¦å…‹é£æƒé™...');
    
    // ä¿®å¤ï¼šä½¿ç”¨æ›´å…¼å®¹çš„éŸ³é¢‘çº¦æŸ
    this.mediaStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        sampleRate: { ideal: this.sampleRate },
        channelCount: { exact: this.channels },
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true,
        // æ·»åŠ å»¶è¿Ÿä¼˜åŒ–
        latency: { ideal: 0.01 }
      }
    });

    console.log('éº¦å…‹é£æƒé™è·å–æˆåŠŸ');

    if (!this.audioContext || !this.analyserNode) {
      await this.initializeAudioContext();
    }

    // ä¿®å¤ï¼šç¡®ä¿éŸ³é¢‘ä¸Šä¸‹æ–‡å¤„äºè¿è¡ŒçŠ¶æ€
    if (this.audioContext!.state === 'suspended') {
      console.log('æ­£åœ¨æ¢å¤éŸ³é¢‘ä¸Šä¸‹æ–‡...');
      await this.audioContext!.resume();
    }

    // åˆ›å»ºæºèŠ‚ç‚¹
    this.sourceNode = this.audioContext!.createMediaStreamSource(this.mediaStream);
    
    // ä¿®å¤ï¼šä½¿ç”¨æ›´å°çš„ç¼“å†²åŒºå¤§å°ä»¥å‡å°‘å»¶è¿Ÿ
    const bufferSize = 2048; // å‡å°ç¼“å†²åŒºå¤§å°
    this.scriptProcessorNode = this.audioContext!.createScriptProcessor(
      bufferSize, 
      this.channels, 
      this.channels
    );

    // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹
    this.sourceNode.connect(this.analyserNode!);
    this.analyserNode!.connect(this.scriptProcessorNode);
    this.scriptProcessorNode.connect(this.audioContext!.destination);

    // è®¾ç½®éŸ³é¢‘å¤„ç†å›è°ƒ
    this.scriptProcessorNode.onaudioprocess = (event) => {
      try {
        this.processAudioData(event);
      } catch (error) {
        console.error('éŸ³é¢‘æ•°æ®å¤„ç†å¤±è´¥:', error);
      }
    };

    this.isRecording = true;
    this.silenceStartTime = Date.now();
    
    console.log('éŸ³é¢‘æ•è·å·²å¼€å§‹ï¼Œé‡‡æ ·ç‡:', this.audioContext!.sampleRate);

  } catch (error) {
    console.error('å¼€å§‹éŸ³é¢‘æ•è·å¤±è´¥:', error);
    this.cleanup();
    
    // æä¾›æ›´å…·ä½“çš„é”™è¯¯ä¿¡æ¯
    if (error instanceof Error) {
      if (error.name === 'NotAllowedError') {
        throw new Error('éº¦å…‹é£æƒé™è¢«æ‹’ç»ï¼Œè¯·åœ¨æµè§ˆå™¨è®¾ç½®ä¸­å…è®¸è®¿é—®éº¦å…‹é£');
      } else if (error.name === 'NotFoundError') {
        throw new Error('æœªæ‰¾åˆ°å¯ç”¨çš„éº¦å…‹é£è®¾å¤‡');
      } else if (error.name === 'NotSupportedError') {
        throw new Error('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒéŸ³é¢‘æ•è·');
      } else if (error.name === 'NotReadableError') {
        throw new Error('éº¦å…‹é£è®¾å¤‡è¢«å…¶ä»–åº”ç”¨å ç”¨');
      } else {
        throw new Error(`éŸ³é¢‘æ•è·å¤±è´¥: ${error.message}`);
      }
    } else {
      throw new Error('éŸ³é¢‘æ•è·å¤±è´¥: æœªçŸ¥é”™è¯¯');
    }
  }
}

/**
 * ä¿®å¤ï¼šæ”¹è¿›çš„éŸ³é¢‘æ•°æ®å¤„ç†æ–¹æ³•
 */
private processAudioData(event: AudioProcessingEvent): void {
  if (!this.isRecording || !this.onAudioData) return;

  const inputBuffer = event.inputBuffer;
  const channelData = inputBuffer.getChannelData(0);

  // ä¿®å¤ï¼šé‡é‡‡æ ·åˆ°ç›®æ ‡é‡‡æ ·ç‡ï¼ˆå¦‚æœéœ€è¦ï¼‰
  let processedData = channelData;
  if (inputBuffer.sampleRate !== this.sampleRate) {
    processedData = this.resampleAudio(channelData, inputBuffer.sampleRate, this.sampleRate);
  }

  // è®¡ç®—éŸ³é‡ç”¨äºé™éŸ³æ£€æµ‹
  const volume = this.calculateVolume(processedData);

  // é™éŸ³æ£€æµ‹
  if (volume < this.silenceThreshold) {
    if (this.silenceStartTime === 0) {
      this.silenceStartTime = Date.now();
    } else {
      const silenceDuration = Date.now() - this.silenceStartTime;
      if (this.onSilenceDetected && silenceDuration > 1000) {
        this.onSilenceDetected(silenceDuration);
      }
    }
  } else {
    this.silenceStartTime = 0;
  }

  // ç”Ÿæˆå¯è§†åŒ–æ•°æ®
  if (this.onVisualizationData && this.analyserNode) {
    const visualizationData = this.generateVisualizationData(volume);
    this.onVisualizationData(visualizationData);
  }

  // è½¬æ¢ä¸ºPCMæ ¼å¼å¹¶å‘é€
  const pcmData = this.convertToPCM(processedData);
  this.onAudioData(pcmData.buffer as ArrayBuffer);
}

/**
 * æ–°å¢ï¼šç®€å•çš„é‡é‡‡æ ·æ–¹æ³•
 */
private resampleAudio(input: Float32Array, inputRate: number, outputRate: number): Float32Array {
  if (inputRate === outputRate) {
    return input;
  }

  const ratio = inputRate / outputRate;
  const outputLength = Math.floor(input.length / ratio);
  const output = new Float32Array(outputLength);

  for (let i = 0; i < outputLength; i++) {
    const sourceIndex = i * ratio;
    const index = Math.floor(sourceIndex);
    const fraction = sourceIndex - index;

    if (index + 1 < input.length) {
      // çº¿æ€§æ’å€¼
      output[i] = input[index] * (1 - fraction) + input[index + 1] * fraction;
    } else {
      output[i] = input[index];
    }
  }

  return output;
}
```
### 6. **å‹ç¼©é—®é¢˜ä¿®å¤**
```
/**
 * ä¿®å¤åçš„å‹ç¼©/è§£å‹æ–¹æ³•
 */

/**
 * å‹ç¼©æ•°æ® - ä¿®å¤ç‰ˆæœ¬ï¼Œå…¼å®¹æ€§æ›´å¥½
 */
private async compressData(data: Uint8Array): Promise<Uint8Array> {
  try {
    // ä¼˜å…ˆä½¿ç”¨CompressionStreamï¼ˆè¾ƒæ–°çš„æµè§ˆå™¨ï¼‰
    if ('CompressionStream' in window) {
      const stream = new CompressionStream('gzip');
      const writer = stream.writable.getWriter();
      const reader = stream.readable.getReader();
      
      // å†™å…¥æ•°æ®
      await writer.write(data);
      await writer.close();
      
      // è¯»å–å‹ç¼©åçš„æ•°æ®
      const chunks: Uint8Array[] = [];
      let done = false;
      
      while (!done) {
        const { value, done: streamDone } = await reader.read();
        done = streamDone;
        if (value) {
          chunks.push(value);
        }
      }
      
      // åˆå¹¶chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result;
    } 
    // é™çº§æ–¹æ¡ˆï¼šå¦‚æœä¸æ”¯æŒCompressionStreamï¼Œè¿”å›åŸå§‹æ•°æ®
    else {
      console.warn('CompressionStream not supported, sending uncompressed data');
      // æ·»åŠ ç®€å•çš„æ ‡è®°ï¼Œè¡¨æ˜è¿™æ˜¯æœªå‹ç¼©çš„æ•°æ®
      return data;
    }
  } catch (error) {
    console.error('Compression failed:', error);
    // å‹ç¼©å¤±è´¥æ—¶è¿”å›åŸå§‹æ•°æ®
    return data;
  }
}

/**
 * è§£å‹æ•°æ® - ä¿®å¤ç‰ˆæœ¬
 */
private async decompressData(data: Uint8Array): Promise<Uint8Array> {
  try {
    if ('DecompressionStream' in window) {
      const stream = new DecompressionStream('gzip');
      const writer = stream.writable.getWriter();
      const reader = stream.readable.getReader();
      
      await writer.write(data);
      await writer.close();
      
      const chunks: Uint8Array[] = [];
      let done = false;
      
      while (!done) {
        const { value, done: streamDone } = await reader.read();
        done = streamDone;
        if (value) {
          chunks.push(value);
        }
      }
      
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result;
    } else {
      // å¦‚æœä¸æ”¯æŒDecompressionStreamï¼Œå‡è®¾æ•°æ®æœªå‹ç¼©
      return data;
    }
  } catch (error) {
    console.error('Decompression failed:', error);
    // è§£å‹å¤±è´¥æ—¶è¿”å›åŸå§‹æ•°æ®
    return data;
  }
}
```
## å®Œæ•´ä¿®å¤æ–¹æ¡ˆæ€»ç»“

æ ¹æ®åˆ†æï¼Œä½ çš„è±†åŒ…è¯­éŸ³é›†æˆä¸»è¦å­˜åœ¨ä»¥ä¸‹é—®é¢˜ï¼š

### ğŸ”§ **ç«‹å³éœ€è¦ä¿®å¤çš„é—®é¢˜**

1. **WebSocketä»£ç†æœåŠ¡å™¨headersç¼ºå¤±** âŒ
   - ç¼ºå°‘ `X-Api-App-Key: 'PlgvMymc7f3tQnJ6'`
   - éœ€è¦å®Œæ•´çš„åè®®åˆå§‹åŒ–æµç¨‹

2. **åè®®å®ç°ä¸å®Œæ•´** âŒ  
   - ç¼ºå°‘StartConnectionå’ŒStartSessionæ­¥éª¤
   - å¤´éƒ¨ç”Ÿæˆç®—æ³•æœ‰è¯¯
   - ç¼ºå°‘æ­£ç¡®çš„ç»“æŸæµç¨‹

3. **éŸ³é¢‘å¤„ç†é—®é¢˜** âŒ
   - PCMæ ¼å¼è½¬æ¢å¯èƒ½æœ‰ç²¾åº¦é—®é¢˜
   - é‡‡æ ·ç‡å¤„ç†ä¸å½“
   - ç¼ºå°‘é‡é‡‡æ ·åŠŸèƒ½

4. **å‹ç¼©å…¼å®¹æ€§é—®é¢˜** âŒ
   - CompressionStream APIå…¼å®¹æ€§å¤„ç†ä¸å½“

### ğŸ“‹ **ä¿®å¤æ­¥éª¤**

1. **æ›¿æ¢ `server.js`** - ä½¿ç”¨ä¿®å¤åçš„ç‰ˆæœ¬ï¼Œæ·»åŠ å®Œæ•´headerså’Œåè®®æµç¨‹
2. **æ›´æ–° `doubaoVoiceClient.ts`** - æ·»åŠ æ­£ç¡®çš„è¿æ¥åˆå§‹åŒ–æµç¨‹
3. **ä¼˜åŒ– `audioProcessor.ts`** - æ”¹è¿›PCMè½¬æ¢å’Œé‡é‡‡æ ·
4. **æµ‹è¯•è¿æ¥æµç¨‹** - ç¡®ä¿å®Œæ•´çš„åè®®æ¡æ‰‹

### ğŸš€ **éªŒè¯ä¿®å¤æ•ˆæœ**

ä¿®å¤åï¼Œä½ åº”è¯¥çœ‹åˆ°ä»¥ä¸‹æ—¥å¿—è¾“å‡ºï¼š
```
> WebSocketä»£ç†è¿æ¥å·²å»ºç«‹ï¼Œå¼€å§‹åè®®åˆå§‹åŒ–...
> å·²å‘é€StartConnectionè¯·æ±‚  
> å·²å‘é€StartSessionè¯·æ±‚
> è±†åŒ…æœåŠ¡è¿æ¥æˆåŠŸ
> éŸ³é¢‘æ•è·å·²å¼€å§‹ï¼Œé‡‡æ ·ç‡: 16000
```

### âš ï¸ **æ³¨æ„äº‹é¡¹**

1. **ç¡®ä¿ä½¿ç”¨æœ€æ–°çš„Chrome/Firefox/Edgeæµè§ˆå™¨**
2. **åœ¨HTTPSç¯å¢ƒä¸‹æµ‹è¯•** - HTTPå¯èƒ½æœ‰å®‰å…¨é™åˆ¶
3. **æ£€æŸ¥éº¦å…‹é£æƒé™** - ç¡®ä¿ç”¨æˆ·æˆæƒ
4. **ç›‘æ§WebSocketè¿æ¥çŠ¶æ€** - æ·»åŠ é‡è¿æœºåˆ¶

æŒ‰ç…§è¿™äº›ä¿®å¤æ–¹æ¡ˆï¼Œä½ çš„è±†åŒ…è¯­éŸ³é€šè¯åŠŸèƒ½åº”è¯¥èƒ½å¤Ÿæ­£å¸¸å·¥ä½œäº†ï¼